	<PG title="inventory" name="inventory">		<SCR name="getPageID"><![CDATA[pageIcon = icon.parentNode.clip();if (rootIcon.projMode == "dev"){  // Page Wizard   pageIcon.templateData = pageIcon.extXML.toObject();  pageIcon.templateData = pageIcon.templateData.pageWizard[0];    // establish page location issues that affect navigation calls  // establish container     myLocXML = String(icon.parentNode.parentNode);    myLocXML = myLocXML.substr(1,3);    if (myLocXML == "IFC"){        container = "Interface";  } else if (myLocXML == "FW ") {      container = "Framework";  }  else {     // unspecified        container = "U";    }    // establish navigationOffset to cope with effect of an entryFrame  firstC = String(icon.parentNode.parentNode.firstChild);  firstC = firstC.substr(1,6);  if (firstC == "FW_ENT") {    navigationOffset = 1;   // use - navigationOffset  } else {       navigationOffset = 0;  }    } else {  // Toolkits    myXML = new XML(extXML.firstChild.childNodes[rootIcon.getPageIndex() - pgOffset]);  pageIcon.templateData = myXML.toObject();    navigationOffset = 1;  container = "Interface";}  rootIcon.setTitleText(templateData.learningObject[0].name);// handle multiple page data definitions in a project if (rootIcon.projectPageIndex == undefined){     rootIcon.projectPageIndex = 0;}// check if this page has a definition for the current project index and default to 0 if notif (pageIcon.templateData.inventory[rootIcon.projectPageIndex].name == undefined){  projPI = 0;} else {  projPI = rootIcon.projectPageIndex; }  if (templateData.learningObject[0].authorSupport == "true"){  pageMode = "development";} else {  pageMode = "live";}     //make questionsif (icon.attributes.built != 'true'){  icon.parentNode.getChildByName("questions").firstChild.duplicate(pageIcon.templateData.inventory[projPI].invQuestion.length - 1);  icon.attributes.built = 'true';}// classLabels stores the class descriptions so they can be matched to the class numbers// class number 0 equates to classLabel[0]classLabels = new Array();classLabels = pageIcon.templateData.inventory[projPI].classes.split(',');// find longest class descriptor to assist in positioning chart latermaxClassLength = 0;for (i = 0; i < classLabels.length; i++){  if (maxClassLength < classLabels[i].length){    maxClassLength = classLabels[i].length;  }}// initialise class weightedtotals - will store sum of weighted scores for options selected for each classclassWeightedTotals = new Array();for (i = 0; i < classLabels.length; i++){  classWeightedTotals[i] = 0;}// initialise classMax (will store maximum possible score for each class classMax = new Array();for (i = 0; i < classLabels.length; i++){  classMax[i] = 0;}// used to calculate the maximum possible score for each class for a specific questionclassQuestionMax = new Array();for (i = 0; i < classLabels.length; i++){  classQuestionMax[i] = 0;}questionCount = 0;align = pageIcon.templateData.inventory[projPI].align;scoreType = pageIcon.templateData.inventory[projPI].scoreType;//sequencingif (pageIcon.templateData.inventory[projPI].order == 'random'){  icon.parentNode.getChildByName("questions").attributes.branch = 'randomUnused';} else {  icon.parentNode.getChildByName("questions").attributes.branch = 'sequence';}//number of questionsif (pageIcon.templateData.inventory[projPI].numQuestions == undefined || pageIcon.templateData.inventory[projPI].numQuestions.toLowerCase() == 'all'){  icon.parentNode.getChildByName("questions").attributes.repeat = 'all';  qCount = pageIcon.templateData.inventory[projPI].invQuestion.length;} else {  icon.parentNode.getChildByName("questions").attributes.repeat = pageIcon.templateData.inventory[projPI].numQuestions;  qCount = pageIcon.templateData.inventory[projPI].numQuestions;}//panelWidth = pageIcon.templateData.inventory[projPI].panelWidth;// chart renders other sizes unsuitablepanelWidth = "Large";  panelW = 600;  textW = 150;// set up instructionsexplanationString = pageIcon.templateData.inventory[projPI].instructions;// set up display text itemsquesCount = pageIcon.templateData.inventory[projPI].quesCount; feedbackLabel = pageIcon.templateData.inventory[projPI].feedbackLabel;testModeText = pageIcon.templateData.inventory[projPI].testModeText;submitBtnText = pageIcon.templateData.inventory[projPI].submitBtnText;submitBtnTip = pageIcon.templateData.inventory[projPI].submitBtnTip;submitBtnWidth = pageIcon.templateData.inventory[projPI].submitBtnWidth;nextBtnText = pageIcon.templateData.inventory[projPI].nextBtnText;nextBtnTip = pageIcon.templateData.inventory[projPI].nextBtnTip;nextBtnWidth = pageIcon.templateData.inventory[projPI].nextBtnWidth;restartBtnText = pageIcon.templateData.inventory[projPI].restartBtnText;restartBtnTip = pageIcon.templateData.inventory[projPI].restartBtnTip;restartBtnWidth = pageIcon.templateData.inventory[projPI].restartBtnWidth;// add narrationif (pageIcon.templateData.inventory[projPI].narration != undefined){  narration = pageIcon.templateData.inventory[projPI].narration;  rootIcon.broadcast('showAudio');}]]></SCR>		<DIS tabIndex="-1" id="panel" h="474" w="panelW" name="panel" x="align == 'left' ? 20 : 780 - panelW" y="20" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<INT name="loadPanel" perpetual="0">			<RES name="onLoad" type="event" eventName="onLoad" icon="panel" erase="1" exit="1">				<SCR name="calculate"><![CDATA[//ok to move on]]></SCR>			</RES>		</INT>		<DIS id="explanation" name="explanation" x="align == 'left' ? panel._x + panel._width + 20 : 20" y="20" w="textW" h="10" type="text"><![CDATA[{explanationString}]]></DIS>		<DEC id="inventory" name="questions" repeat="all" branch="blaH" pause="0" erase="1" eraseOnExit="0">			<PG name="protoQuestion">				<SCR name="setup"><![CDATA[if (pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].image != undefined){  prptWidth = (panelW / 2) - 30;} else {  icon.parentNode.getChildByName("loader").removeNode();  prptWidth = panelW - 40;}invPrompt = "<b>" + quesCount + "</b>";invPrompt = replace(invPrompt, "{i}", inventory.repCount);invPrompt = replace(invPrompt, "{n}", qCount);invPrompt = invPrompt + "<br><br>" + pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].prompt;  ]]></SCR>				<DIS textColour="#000000" id="prpt" name="Prompt" x="panel._x + 20" y="panel._y + 20" w="prptWidth" h="10" type="text"><![CDATA[{invPrompt}]]></DIS>				<DIS tabIndex="-1" id="image" name="image" x="prpt._x + prpt._width + 20" y="prpt._y" type="ext" url="{pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].image}"><![CDATA[]]></DIS>				<INT name="loader" perpetual="0">					<RES name="onLoad" type="event" eventName="onLoad" icon="image" erase="1" exit="1">						<SCR name="resize"><![CDATA[image.constrain(prptWidth, panel._height - 40);p = image._width / image._height;image._x = panel._x + panel._width - 20 - image._width;]]></SCR>					</RES>				</INT>				<SCR name="makeOptions"><![CDATA[ln = pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption.length;if (ln > 2 && icon.attributes.built != 'true'){  icon.nextSibling.childNodes[1].duplicate(ln - 2);  icon.attributes.built = 'true';}//multi answer? then display check boxes rather than radio buttonsif (pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].type == 'Multiple Answer'){  for (i = 0; i < ln; i++){    icon.nextSibling.childNodes[i].attributes.type="checkBox";  }}// sets up optionTracking array with one element per option and set element values to 0optionTracking = new Array();for (i = 0; i < ln; i++){  optionTracking[i] = 0;// all options are correct in an inventory// check boxes are only flagged as 1 in optionTracking if they are selected and have their correct// attribute set    icon.nextSibling.childNodes[i].attributes.correct = 1;}]]></SCR>				<INT id="[Untitled]" name="protoInteraction" perpetual="0">					<RES w="prptWidth" textColour="#000000" name="protoOption" type="radio" x="prpt._x" y="prpt._y + prpt._height + 20" label="{pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[icon.index()].text}" group="grp" erase="1" exit="0">						<SCR name="trackOptions"><![CDATA[// this script runs each time a radio button is clicked on// capture which options have been selectedif (pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].type == 'Single Answer'){  for (i = 0; i < ln; i++){    optionTracking[i] = 0;  }  optionTracking[icon.parentNode.index()] = 1;} if (pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].type == 'Multiple Answer'){  if (icon.parentNode.clip().getValue() == true){    optionTracking[icon.parentNode.index()] = 1;  } else {    optionTracking[icon.parentNode.index()] = 0;  }}// enable submit button only if the question has not been submittedif (questionSubmitted == undefined || questionSubmitted == false) {   btnSubmit.setEnabled(true);}]]></SCR>					</RES>					<RES w="prptWidth" textColour="#000000" name="protoOption" type="radio" x="prpt._x" y="_ytile + 10" label="{pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[icon.index()].text}" group="grp" erase="1" exit="0">						<SCR name="trackOptions"><![CDATA[// this script runs each time a radio button is clicked on// capture which options have been selectedif (pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].type == 'Single Answer'){  for (i = 0; i < ln; i++){    optionTracking[i] = 0;  }  optionTracking[icon.parentNode.index()] = 1;} if (pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].type == 'Multiple Answer'){  if (icon.parentNode.clip().getValue() == true){    optionTracking[icon.parentNode.index()] = 1;  } else {    optionTracking[icon.parentNode.index()] = 0;  }}// enable submit button only if the question has not been submittedif (questionSubmitted == undefined || questionSubmitted == false) {   btnSubmit.setEnabled(true);}]]></SCR>					</RES>					<RES w="submitBtnWidth" toolTip="{submitBtnTip}" swf="templatePath + 'common/button.swf'" enabled="false" rs="btnSubmit" name="submit" type="button" x="icon.previousSibling.clip()._x" y="_ytile + 10" label="{submitBtnText}" erase="1" exit="0">						<SCR name="makeFeedback"><![CDATA[fb = "";if (pageMode == "development"){  // In test mode option class descriptions are displayed  // Question feedback is not output even if questionFeedback is set to "yes"  for (i = 0; i < ln; i++){     tempClass = classLabels[Number(pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].class)];     tempWeight = pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].weight;     fb += tempClass + " : " + tempWeight +  '\r';   }  fb = '<b>' + testModeText + '</b><br>' + fb;}  else {    // in live mode  if (pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].questionFeedback == "yes") {    // questionFeedback for this question = 'yes' so display feedback for selected option(s)    for (i = 0; i < ln; i++){      if (optionTracking[i] == 1){ // only display feedback for selected responses        fb += pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].feedback + '\r\r';       }    }    fb = '<b>' + feedbackLabel + '</b><br>' + fb;  }}]]></SCR>						<SCR name="scoreQuestion"><![CDATA[// this script runs once the user submits their response// option tracking records which options are selected and takes no account of option class// e.g. 0,1,0 indicates second option was selected, 0 1,1, // indicates options 2 and 3 selected in a multi- answer question questionCount++;// update the classMax values to include this questions optionsif (pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].type == 'Multiple Answer'){  // we need to add all the weightings for each class to the classMax value  for (i = 0; i < ln; i++){ // loop through all the options     currentClassNum = Number(pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].class);     classMax[currentClassNum] += Number(pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].weight);  }}else {  // initialise store for question class totals  for (i = 0; i < classLabels.length; i++){    classQuestionMax[i] = 0;  }    // we need to find the highest weighting for each class  for (i = 0; i < ln; i++){ // loop through all the options     currentClassNum = Number(pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].class);    if (Number(classQuestionMax[currentClassNum]) < Number(pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].weight)) {       // add weight to classQuestionMax if it is higher than current value      classQuestionMax[currentClassNum] = Number(pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].weight);    }   }  // finished looping through options    // now add currentQuestionMax to classMax  for (i = 0; i < classLabels.length; i++){     classMax[i] += classQuestionMax[i];  }} // end of else// add all selected scores to the classWeightedTotalsfor (i = 0; i < ln; i++){    // get the class number of the option and convert to a number     currentClassNum = Number(pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].class);   if (optionTracking[i] == 1){   // increase classWeightedTotals by score for this item       classWeightedTotals[currentClassNum] += Number(pageIcon.templateData.inventory[projPI].invQuestion[inventory.getPageIndex()].invOption[i].weight);   }}]]></SCR>						<DIS scrolling="auto" textColour="#000000" name="feedback" x="btnSubmit._x" y="btnSubmit._y + btnSubmit._height" w="prptWidth" h="474 - (btnSubmit._y + btnSubmit._height) - 40" type="text"><![CDATA[{fb}]]></DIS>						<SCR name="enableNext"><![CDATA[btnNext._visible = true;btnNext.setEnabled(true);btnSubmit.setEnabled(false);btnSubmit._visible = false;questionSubmitted = true;]]></SCR>					</RES>					<RES w="nextBtnWidth" visible="0" toolTip="{nextBtnTip}" enabled="false" rs="btnNext" swf="templatePath + 'common/button.swf'" name="next" type="button" x="icon.previousSibling.clip()._x" y="455" label="{nextBtnText}" erase="1" exit="1">						<SCR name="next"><![CDATA[//move onquestionSubmitted = false;btnSubmit._visible = true;btnNext._visible = true;]]></SCR>					</RES>				</INT>			</PG>		</DEC>		<SCR name="finalise scores"><![CDATA[/** this page receives* classLabels - "label0,label1,label2" max 10 labels* classWeightedTotals - "0,2,3,2" one Total for each class being number the sum of the weights*   of the options selected for each class * classMax - being the maximum possible score achievable for each class* questionCount -  the number of questions asked* * scoring methods* absolute - actual count of number of selected options for each class* individual percent = classTotals / classMax x 100* relative percent = individual percent / sum of individual percents x 100  */fb = "";// scoreTypeChar is displayed on the key to the chartscoreTypeChar = "";finalScores = new Array();if (scoreType == "absolute"){   finalScores = classWeightedTotals;}else {  // percentage = number of selected for class / total options for class x 100  scoreTypeChar = "%";  percentTotal = 0;  classOptionPercent = new Array();    for (i = 0; i < classLabels.length; i++){    classOptionPercent[i] = Math.ceil(classWeightedTotals[i] / classMax[i] * 100);    if (isNaN(classOptionPercent[i])){      classOptionPercent[i] = 0;    }    percentTotal = percentTotal + classOptionPercent[i];  }  if (scoreType == "relative percent"){    // rework percentages to give percentage relative to each other    for (i = 0; i < classOptionPercent.length; i++){      classOptionPercent[i] = Math.ceil(classOptionPercent[i] / percentTotal * 100);    }     }  // set up scorm values  finalScores = classOptionPercent;}// if scorm support is to be implemented it needs to go here// as the score processing is now completed]]></SCR>		<SCR name="prepare chart data"><![CDATA[// prepare chart data from scores// convert NaN scores to 0 - these will occur if a class is defined but not usedfor (i = 0; i < finalScores.length; i++){  if ( isNaN(finalScores[i]) || finalScores[i] == undefined){    finalScores[i] = 0;   }}/****************************************************** * convert chart data to array of object pairs* structure required is* "label|score||label|score||label|score||label|score"*************************************************/myData = "";for (i = 0; i < classLabels.length; i++){  myData += classLabels[i] + "|" + finalScores[i].toString() + "||";}// remove the last ||myData = myData.substr(0,myData.length -2);yMin = Infinity;yMax = 0;cd = new Array();//for (i = 0; i < s.length; i++){for (i = 0; i < 1; i++){  cd.push(new Array());    temp = myData.split('||');    // at this point the data string "temp" has become // label1|score2,label2|score2,label3,score3   for (j = 0; j < temp.length; j++){    cd[i].push(new Object());    cd[i][j].x = temp[j].split('|')[0];    cd[i][j].y = temp[j].split('|')[1];    if (Number(cd[i][j].y) < yMin){      yMin = cd[i][j].y;    }    if (Number(cd[i][j].y) > yMax){      yMax = cd[i][j].y;    }  } // end of j loop} // end of for i loop// set min to 0 if using percentagesif (pageIcon.templateData.inventory[projPI].scoreType != 'absolute'){ yMin = 0;}if (Number(yMin) > 0){  yMin = yMin -1;} ]]></SCR>		<DIS id="finalScore" name="finalScore" x="panel._x + 20" y="panel._y + 20" w="400" h="10" type="text"><![CDATA[{fb}]]></DIS>		<DIS textColour="0x333333" name="title" x="panel._x" y="panel._y + 10" w="420" h="10" type="text"><![CDATA[{'<b><p align="center">' + pageIcon.templateData.inventory[projPI].chartTitle + '</p></b>'}]]></DIS>		<DIS id="chart" name="chart" x="panel._x + 60" y="panel._y + 10" w="400" h="10" type="text"><![CDATA[]]></DIS>		<SCR name="drawChart"><![CDATA[/* ************************ Incoming data for use in chart* cd - a 2 dimensional array, probably because charts can have more than one series* cd[0][0] identifies an object in a series with two properties*   x = numerical score*   y = text descriptor (in this case the class)* *  scoreTypeChar - a string which is "" if absolute or "%" if percentage scoring type*  maxClassLength - number that is the length of the longest class label*/// remove initial instructions and display inventory feedbackexplanationString = pageIcon.templateData.inventory[projPI].feedback;explanation.setText(explanationString);lblFormat = new TextFormat('Verdana', 10, 0x333333);lblFormat.align = 'center';lgdFormat = new TextFormat('Verdana', 10, 0x333333);lgdFormat.align = 'left';minMaxFormat = new TextFormat('Verdana', 10, 0x333333);minMaxFormat.align = 'right';hMax = 440 - 30 - 20;scalar = hMax / (yMax - yMin);//draw the axisif (pageIcon.templateData.inventory[projPI].chartType != 'pie'){  // set up starting values  xStart = 60 + Number(maxClassLength) * 4;  // formerly 80  yStart = 50;  axisHeight = hMax;  axisWidth = panelW - xStart - 100;  w = (axisWidth)/ cd[0].length;  w1 = w*0.9 / cd.length;  chart.lineStyle(0,0x333333,100);  chart.moveTo(xStart,yStart);  chart.lineTo(xStart,yStart + axisHeight);  chart.moveTo(xStart-5,yStart + axisHeight -5);  chart.lineTo(xStart-5 + axisWidth,yStart + axisHeight -5);  chart.lineStyle();  //draw the legend  colOff = 100 / cd[0].length;  for (i = 0;i < cd[0].length; i++){    chart.beginFill(pageIcon.templateData.inventory[projPI].chartColour, 100 - colOff*i);    chart.drawRect(-50,25 + i*20,12,12);    chart.createTextField('lgd' + i, i, -30,25+i*20 - 3,300,20);    chart['lgd' + i].text = cd[0][i].x + " " + cd[0][i].y + scoreTypeChar;    chart['lgd' + i].setTextFormat(lgdFormat);  }  //draw the x labels  for (i = 0; i < cd[0].length; i++){    chart.createTextField('lbl' + i, i+10, xStart + (w*i),yStart + axisHeight,w,20);    chart['lbl' + i].text = cd[0][i].x;    chart['lbl' + i].setTextFormat(lblFormat);  }    //draw the y lables  chart.createTextField('min', 99,xStart -50,yStart + axisHeight -10,45,20);  chart.min.text = yMin;  chart.min.setTextFormat(minMaxFormat);  chart.createTextField('max', 98,xStart -50,yStart -10,45,20);  chart.max.text = yMax;  chart.max.setTextFormat(minMaxFormat);  } // end of if not pie chart//LINE------------------------------------------------if (pageIcon.templateData.inventory[projPI].chartType == 'line'){  for (i = 0; i < cd.length; i++){ //for each series    chart.beginFill();    chart.lineStyle(2,pageIcon.templateData.inventory[projPI].chartColour,100);    chart.moveTo(w/2 + xStart, yStart + axisHeight - 5 - (cd[i][0].y - yMin) * scalar);    for (j = 0; j < cd[i].length; j++){      chart.lineTo(w*j + w/2 + xStart, yStart + axisHeight - 5 - (cd[i][j].y - yMin) * scalar);    }  }}//BAR CHARTS------------------------------------------if (pageIcon.templateData.inventory[projPI].chartType == 'bar'){    for (i = 0; i < cd.length; i++){ //for each series    for (j = 0; j < cd[i].length; j++){      tempH = (cd[i][j].y - yMin) * scalar;      // draw bar to match legend colour      chart.beginFill(pageIcon.templateData.inventory[projPI].chartColour, 100 - colOff*j);      chart.drawRect((w*j) + (i*w1) + xStart, yStart + axisHeight - 5,w*0.9 / 1,-tempH);    }  }}//pie chartsif (pageIcon.templateData.inventory[projPI].chartType == 'pie'){    axisHeight = hMax; // used in positioning the restart button  colOff = 100 / cd[0].length;  for (i = 0;i < cd[0].length; i++){    chart.beginFill(pageIcon.templateData.inventory[projPI].chartColour, 100 - colOff*i);    chart.lineStyle(0,0x333333,100);    chart.drawRect(-50,25 + i*20,12,12);    chart.lineStyle();          chart.createTextField('lgd' + i, i, -30,25 + i*20 - 3,150,20);    chart['lgd' + i].text = cd[0][i].x + " " + cd[0][i].y + scoreTypeChar;    chart['lgd' + i].setTextFormat(lgdFormat);  }  //draw chart  for (i = 0; i < 1; i++){ //for each series    //get the total for this series    sT = 0;    for (j = 0; j < cd[i].length; j++){      sT += Number(cd[i][j].y);    }    exTheta = 90;    for (j = 0; j < cd[i].length; j++){ //draw each segment...      theta = Number(cd[i][j].y) / sT * -360;      chart.beginFill(pageIcon.templateData.inventory[projPI].chartColour, 100 - colOff*j);      chart.drawWedge(270,240, exTheta, theta, 180 - i*(180));      exTheta += theta;    }  }}]]></SCR>		<INT name="restart" perpetual="0">			<RES toolTip="{restartBtnTip}" w="restartBtnWidth" swf="templatePath + 'common/button.swf'" name="restart" type="button" x="panel._x + 10" y="panel._y + axisHeight" label="{restartBtnText}" erase="1" exit="0">				<SCR name="restart"><![CDATA[//rootIcon.gotoPage(rootIcon.getPageIndex() - 1);//rootIcon.gotoPage(rootIcon.getPageIndex() - navOffset);if (container == "Framework"){    fwXML = icon.findParentByType('FW');    pageNum = fwXML.clip().currentPage;    fwXML.clip().gotoPage(pageNum);    }else{       // use for projects   rootIcon.gotoPage(rootIcon.getPageIndex() - navigationOffset);}]]></SCR>			</RES>		</INT>	</PG>