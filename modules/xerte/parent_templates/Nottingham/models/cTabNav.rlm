	<PG title="Tab Nav Connector" name="Tab Navigator Connector">		<SCR name="getPageID"><![CDATA[pageIcon = icon.parentNode.clip();if (rootIcon.projMode == "dev"){// Page Wizard   pageIcon.templateData = pageIcon.extXML.toObject();  pageIcon.templateData = pageIcon.templateData.pageWizard[0];    // routed pages only  pageID_array = new Array();  pageTitle_array = new Array();    for (i = 0; i < rootIcon.pages.length; i++){    pageID_array.push(rootIcon.pages[i].extXML.firstChild.childNodes[0].attributes.pageID);    pageTitle_array.push(rootIcon.pages[i].extXML.firstChild.childNodes[0].attributes.name);  }  navOffset = 0;    } else {  // Toolkits    myXML = new XML(extXML.firstChild.childNodes[rootIcon.getPageIndex() - pgOffset]);  pageIcon.templateData = myXML.toObject();    // routed pages only  pageID_array = new Array();   pageTitle_array = new Array();  for (i = 0; i < extXML.firstChild.childNodes.length; i++){    pageID_array.push(extXML.firstChild.childNodes[i].attributes.pageID);    pageTitle_array.push(extXML.firstChild.childNodes[i].attributes.name);  }  navOffset = pgOffset - 1;  }  rootIcon.setTitleText(templateData.learningObject[0].name);  // handle multiple page data definitions in a project if (rootIcon.projectPageIndex == undefined){     rootIcon.projectPageIndex = 0;}// check if this page has a definition for the current project index and default to 0 if notif (pageIcon.templateData.cTabNav[rootIcon.projectPageIndex].name == undefined){  projPI = 0;} else {  projPI = rootIcon.projectPageIndex; }   ]]></SCR>		<SCR id="fnSetNavigation" isFunc="1" name="fnSetNavigation"><![CDATA[// next button and continue buttonif (nextSet != undefined){  rootIcon.nextBtn.setEnabled(nextSet);  rootIcon.contButton.setEnabled(nextSet);	}// back buttonif (backSet != undefined){	  rootIcon.backBtn.setEnabled(backSet);}// table of contentsif (tocSet != undefined){	  rootIcon.tocBtn.setEnabled(tocSet);}]]></SCR>		<SCR isFunc="1" id="fnListToClipboard" name="fnListToClipboard"><![CDATA[// outputs a list of page titles and page ids to the clipboardclipBoardText = "";if (reportStyle == "text"){  for (i = 0; i < pageID_array.length; i++){     // output a list of titles and pageIDs    clipBoardText = clipBoardText + pageLabel + " " + (i + 1) + " " + titleLabel + " " + pageTitle_array[i] + " | " + idLabel + " " + pageID_array[i] + chr(13) + chr(10);  }  System.setClipboard(clipBoardText);} else if (reportStyle == "html"){// html versionclipBoardText = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';clipBoardText = clipBoardText + chr(13) + chr(10);clipBoardText = clipBoardText + '<html><head><title>' + reportTitle + '</title></head><body>';clipBoardText = clipBoardText + chr(13) + chr(10);clipBoardText = clipBoardText + '<table border="1" cellpadding="5">' + chr(13) + chr(10);clipBoardText = clipBoardText + '<tr><td bgcolor="yellow">' + pageLabel + '</td><td bgcolor="lightgreen">' + titleLabel + '</td><td bgcolor="lightblue">' + idLabel + '</td></tr>' + chr(13) + chr(10);  for (i = 0; i < pageID_array.length; i++){      clipBoardText = clipBoardText + '<tr><td bgcolor="yellow">' + (i + 1) + '</td><td bgcolor="lightgreen">' + pageTitle_array[i] + '</td><td bgcolor="lightblue">' + pageID_array[i]  + '</td></tr>' + chr(13) + chr(10);  }  clipBoardText = clipBoardText + '</table></body></html>' + chr(13) + chr(10);  System.setClipboard(clipBoardText);} else {  // do nothing}]]></SCR>		<SCR name="set up"><![CDATA[reportTitle = pageIcon.templateData.cTabNav[projPI].reportTitle;pageLabel = pageIcon.templateData.cTabNav[projPI].pageLabel;titleLabel = pageIcon.templateData.cTabNav[projPI].titleLabel;idLabel = pageIcon.templateData.cTabNav[projPI].idLabel;notFoundMessage = pageIcon.templateData.cTabNav[projPI].notFoundMessage;notSetMessage = pageIcon.templateData.cTabNav[projPI].notSetMessage;if (templateData.learningObject[0].authorSupport == "true"){  pageMode = "development";} else {  pageMode = "live";} if ((pageMode == "development") && (pageIcon.templateData.cTabNav[projPI].listToClip != undefined)){  reportStyle = pageIcon.templateData.cTabNav[projPI].listToClip;  fnListToClipboard();}// set navigation to be used by destination page  nextState = 1;  backState = 1;  tocState = 1;// configure navigation settings for this page;if (pageIcon.templateData.cTabNav[projPI].pageNav == "none"){  nextSet = 0;  backSet = 0;  tocSet = 0;} else {// all  nextSet = 1;  backSet = 1;  tocSet = 1;}// action navigation settingsfnSetNavigation();if (rootIcon.getProperty('visuals') == "1") {  tabVOffset = 15;}  else {  tabVOffset = 30;}itemCount = pageIcon.templateData.cTabNav[projPI].cTabScreen.length);panelWidth = pageIcon.templateData.cTabNav[projPI].panelWidth;if (panelWidth == "small"){  panelW = 300;  textW = 440;} else if (panelWidth == "medium"){  panelW = 450;  textW = 290;} else if (panelWidth == "large"){  panelW = 600;  textW = 150;} else {  panelW = 760;  textW = 0;}if (pageIcon.templateData.cTabNav[projPI].tabWidth == undefined){  tabW = 100;} else {  tabW = Number(pageIcon.templateData.cTabNav[projPI].tabWidth);}// set up display of panel dimensions if in development modeif (pageIcon.templateData.cTabNav[projPI].pageMode == "development"){  if (rootIcon.getProperty('visuals') == "1" || rootIcon.getProperty('visuals') == undefined) {    panelHInfo = "458";  }  else {    panelHInfo = "530";    }  layoutInfo = "Panel width = " + panelW + ", height = " + panelHInfo + ", mode = Development"; }else {  layoutInfo = "";}if (pageIcon.templateData.cTabNav[projPI].narration != undefined){  narration = pageIcon.templateData.cTabNav[projPI].narration;  rootIcon.broadcast('showAudio');}]]></SCR>		<DIS h="rootIcon.visuals == true ? 458:530" w="panelW" tabIndex="-1" id="panel" name="panel" x="780 - panelW" y="22 + tabVOffset" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<DIS scrolling="auto" id="textBlock" h="480" name="text" x="20" y="20" w="textW" type="text"><![CDATA[{pageIcon.templateData.cTabNav[projPI].text}]]></DIS>		<DIS textColour="#FF0000" id="LayoutInfo" name="LayoutInfo" x="0" y="0" w="400" h="10" type="text"><![CDATA[{layoutInfo}]]></DIS>		<SCR name="makeTabs"><![CDATA[if (icon.attributes.built != 'true'){  icon.nextSibling.firstChild.duplicate(itemCount - 1);  icon.attributes.built = 'true';}icon.nextSibling.firstChild.attributes.rs = 'btn1';icon.nextSibling.lastChild.previousSibling.attributes.rs = 'initButton';]]></SCR>		<INT id="tabs" name="tabInteraction" perpetual="0">			<RES enabled="1" w="tabW" swf="templatePath + 'common/tabButton.swf'" name="protoTab" type="button" x="panel._x + (tabW ) * icon.index() + 20" y="tabVOffset" label="{pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.index()].name}" erase="1" exit="0">				<SCR id="checkTab" name="checkTab"><![CDATA[// enable all tabs as if the previous tab had flashPaper it will have been disabledtabArray = icon.parentNode.parentNode.findChildNodes('name','protoTab');for (i = 0; i < tabArray.length; i++){  tabArray[i].clip().setEnabled(true);}btn = icon.parentNode.getMovieClip();btn.setChecked(true,true);if (pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].url == undefined){  icon.nextSibling.nextSibling.attributes.tabIndex = -1;}if (pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].controls == 'Control Bar'){  icon.nextSibling.nextSibling.attributes.controls = '1';}if (pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].movieTransition != undefined){  movieTransition = pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].movieTransition;  switch (movieTransition) {         case "blinds" :             icon.nextSibling.nextSibling.attributes.transition = "blinds('in', 1, 'None', 'easeNone', 10, 3)";            break;         case "dissolve" :             icon.nextSibling.nextSibling.attributes.transition = "dissolve('in', 1, 'None', 'easeNone', 100, 100)";                        break;        case "fade" :             icon.nextSibling.nextSibling.attributes.transition = "fade('in', 1, 'None', 'easeNone')";                          break;        case "fly" :             icon.nextSibling.nextSibling.attributes.transition = "fly('in', 1, 'None', 'easeNone', 6)";                           break;        case "iris" :             icon.nextSibling.nextSibling.attributes.transition = "iris('in', 1, 'None', 'easeNone', 'circle')";                          break;        case "squeeze" :             icon.nextSibling.nextSibling.attributes.transition = "squeeze('in', 1, 'None', 'easeNone', 0)";                        break;        case "wipe" :             icon.nextSibling.nextSibling.attributes.transition = "wipe('in', 1, 'None', 'easeNone', 2)";             break;        case "zoom" :             icon.nextSibling.nextSibling.attributes.transition = "zoom('in', 1, 'None', 'easeNone')";                         break;                                                                                  default :             // no transition            break;     } }if (pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].tip != undefined){  icon.nextSibling.nextSibling.attributes.toolTip = pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].tip;  icon.nextSibling.nextSibling.firstChild.nodeValue = '{' + pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].tip + '}';}]]></SCR>				<DIS textColour="#333333" id="desc" name="description" x="panel._x + 20" y="panel._y + 20" w="panelW - 40" h="10" type="text"><![CDATA[{pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].text}]]></DIS>				<DIS x="desc._x" y="desc._y + desc._height + 20" controls="0" id="graphicOption" name="graphicOption" type="ext" url="{pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].url}"><![CDATA[]]></DIS>				<INT name="loadGraphic&Resize" perpetual="1">					<RES name="onLoad" type="event" eventName="onLoad" icon="graphicOption" erase="1" exit="0">						<SCR name="resize&Position"><![CDATA[/** Because we are allowing the use of flashPaper we have to avoid* resizing the graphic icon, if flashPaper is being used, as this * causes inconsistent resizing issues (flashPaper uses the x and y * properties to change the scaling factor)* but we cannot identify if flashPaper has been used until the* onEnterFrame event has run enough times to detect the flashPaper.* So we must use a user defined property to identify if flashPaper* is being used.*/// set up default values - fp variables are reserved for flashPaperdefaultWidth = graphicOption._width;defaultHeight = graphicOption._height;defaultX = 20 + Number(panel._x);defaultY = 10 + Number(panel._y);fpHeight = defaultHeight;fpWidth = defaultWidth;fpX = defaultX;fpY = defaultY;// if specific settings for the image size and position have been given then use them if (pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize != undefined){  if (!isNaN(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize.split(',')[0])){    defaultX = Number(panel._x) + Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize.split(',')[0]);  }  if (!isNaN(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize.split(',')[1])){     defaultY = Number(panel._y) + Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize.split(',')[1]);  }  if (!isNaN(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize.split(',')[2])){      defaultWidth = Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize.split(',')[2]);  }    if (!isNaN(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize.split(',')[3])){      defaultHeight = Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].movieSize.split(',')[3]);  }}  else { // no specific size or positioning variables provided, so make automatic adjustments  // adjust graphic to available space  space = 393 - desc._height;  graphicOption.constrain(panelW - 40, space);  defaultWidth = graphicOption._width;  defaultHeight = graphicOption._height;  // move picture to the right if we have options  if (pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].cTabExit.length == undefined){    // there are no options    defaultX = panel._x + panel._width / 2 - defaultWidth / 2;    defaultY = desc._y + desc._height + 20;  }  else {    // we have options so move picture to the right    defaultX = panel._x + panel._width - (defaultWidth + 20);    defaultY = desc._y + desc._height + 20;  }}// it is vital that the graphic values are only set if we are not using flashPaperif (pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.parentNode.parentNode.index()].isFlashPaper == 'true'){  // flashPaper  fpHeight = defaultHeight;  fpWidth = defaultWidth;  fpX = defaultX;  fpY = defaultY;}else {  // graphic or ordinary swf  graphicOption._height = defaultHeight;  graphicOption._width = defaultWidth;  graphicOption._x = defaultX;  graphicOption._y = defaultY;} // initialse object script from original page modelif (pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].initObject != undefined){  obj = expression(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].initObject, engine);  graphicOption.clip.init(obj);}]]></SCR>						<INT id="flashPaperResize" name="flashPaperResize" perpetual="1">							<RES name="onEnterFrame" type="event" eventName="onEnterFrame" icon="graphicOption" erase="1" exit="0">								<SCR name="load and size flashPaper"><![CDATA[/* * there are three issues with flashPaper* 1) it is necessary to wait until the swf is identified as being*    flashPaper and this does not happen with the first frame, so*    we have to loop until flashPaper is identified before we*    can set its properties. However if the swf is not flashPaper*    then a loop that exited when flashPaper was detected would *    never exit. So a nominal repeat of 10 cycles has been set*    which should be more than adequate.* 2) When the flashPaper swf is loaded the imageIcon, which is *    the movie clip receiving the flashPaper will resize to the default*    size of the flashPaper which is 550 x 400 for flashPaper 2.0*    Resetting the _height and _width properties of image icon will not work*    as in flashPaper changing the width and height properties adjusts the *    scaling factor, resulting in squashed effects. Instead, once loaded*    you have to use setSize().* 3) Changing the size properties of the graphic icon that will receive the*    flash paper, before the getIFlashPaper() call is made appears to *    cause inconsistent resizing issues.*/if (graphicOption.getLoadedMovie().getIFlashPaper() != undefined){  graphicOption.getLoadedMovie().getIFlashPaper().setSize(fpWidth,fpHeight);  graphicOption._x = fpX;  graphicOption._y = fpY;  myTimeline = graphicOption.getLoadedMovie();  //get the print2flash movie instance  myTimeline.SetCurrentPage(1);  //set to page 1    flashPaperResize.exit();}// provide alternative exit root if we have an ordinary swfif (loopPrevent == undefined){  loopPrevent = 10;}else {  // stay in this script for 10 iterations to give time to locate flashPaper  if (loopPrevent >0){    loopPrevent--;  }  else {  loopPrevent = 10;  flashPaperResize.exit();  }  }]]></SCR>							</RES>						</INT>					</RES>				</INT>				<SCR name="makeOptions"><![CDATA[// adjust tab text position and width if a text offset and width has been definedif (pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].textOffset != undefined){  if (!isNaN(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].textOffset.split(',')[0])){    desc._x = Number(panel._x) + Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].textOffset.split(',')[0]);  }  if (!isNaN(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].textOffset.split(',')[1])){    desc._y = Number(panel._y) + Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].textOffset.split(',')[1]);  }  if (!isNaN(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].textOffset.split(',')[2])){    desc._width = Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].textOffset.split(',')[2]);  }}  // make optionsln = pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].cTabExit.length;if (ln > 0 && icon.attributes.built != 'true'){  icon.nextSibling.childNodes[0].duplicate(ln -1);  icon.attributes.built = "true";}// position first optionicon.nextSibling.firstChild.attributes.x = "desc._x";// y option is dependent on if a Text to option gap has been specified  if (pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].optionVOffset != undefined){  if (!isNaN(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].optionVOffset)){    optionVOffset = Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[tabs.getPageIndex()].optionVOffset);  }}else {  // default gap between tab text and options if no designer defined Text to Option Gap  optionVOffset = 30;}    icon.nextSibling.firstChild.attributes.y = "desc._y + desc._height + optionVOffset";]]></SCR>				<INT id="ques" name="buttonInteraction" perpetual="1">					<RES w="panelW - 60" textColour="#000000" name="protoOption" type="radio" x="desc._x" y="_ytile + 13" label="{pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.parentNode.index()].cTabExit[icon.index()].text} " group="grp" erase="1" exit="0">						<SCR name="routeToPage"><![CDATA[destPageName = pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.parentNode.parentNode.index()].cTabExit[icon.parentNode.index()].destination;exitNav = pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.parentNode.parentNode.index()].cTabExit[icon.parentNode.index()].exitNav;pageFound = "false";if ((destPageName == undefined) || (destPageName == "")) {  // pageID not specified message  txtPageNotFound.setText(notSetMessage);} else {  // a destination has been specified     // navigate to destination page  for (i = 0; i < pageID_array.length; i++){	    if (pageID_array[i] == destPageName){		  pageFound = "true";		  destinationIndex = i;      // setup navigation for next page      if (exitNav == "restrict"){        // just back and next buttons        nextSet = 1;        backSet = 1;        tocSet = 0;      } else {        // all navigation buttons        nextSet = 1;        backSet = 1;        tocSet = 1;      }      // set navigation prior to going to next page           fnSetNavigation();      // go to destination page 	  rootIcon.gotoPage(destinationIndex  + navOffset);  		  break;	    }  }  if (pageFound == "false"){    // pageID was set but not found    txtPageNotFound.setText(idLabel + "<br>" + destPageName + "<br>" + notFoundMessage)  }}if ((pageMode == "development") && (pageFound == "false")){// set up page not found text box  txtPageNotFound.clear();  txtPageNotFound.beginFill(0xFFFFCC, 100);  txtPageNotFound.lineStyle(1,0x000000,100);  txtPageNotFound.drawRect(-10,-10,250,200,20);  txtPageNotFound._visible = 1;  txtPageNotFound.wipe('in',0.25,'Strong','easeIn',2) }]]></SCR>					</RES>				</INT>				<SCR name="Delete options"><![CDATA[// if this tab has no destinations then we remove the buttonInteractionif (pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].cTabExit.length == undefined){  // remove the buttonInteraction for this tab to delete the single radio button  // that is included in the model by default  icon.previousSibling.clip().erase();}]]></SCR>				<SCR name="define Development info"><![CDATA[// this script must run before the routingInfo text icon, otherwise the update of the text property// takes place to late and the destination display for the first tab is undefined// the second tab shows the first tabs destinations etc.if (pageMode == "development"){  // only show destination information in development mode  routingInfoText = "";  routingInfoX = 0;  maxTextLength = 0  // loop through options for this tab and find longest option text whilst building up routing information for this tab  for (i = 0; i < ln; i++){    if (Number(pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].cTabExit[i].text.length) > maxTextLength){      maxTextLength = pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].cTabExit[i].text.length;    }    routingInfoText = routingInfoText + "<li>" + pageIcon.templateData.cTabNav[projPI].cTabScreen[icon.parentNode.index()].cTabExit[i].destination + "</li><br>";  }  // maxTextLength is in characters - need to add a multiplier to allow for character width  maxTextLength = maxTextLength * 6.5;  routingInfoX += maxTextLength + Number(desc._x) + 45;  routingInfoY = Number(desc._y) + Number(desc._height) + Number(optionVOffset) - 8;} ]]></SCR>				<DIS textColour="#FF0000" id="routingInfo" name="routingInfo" x="0" y="0" w="400" h="400" type="text"><![CDATA[{routingInfoText}]]></DIS>				<DIS embedVars="1" textColour="#FF0000" textSize="20" id="txtPageNotFound" name="txtPageNotFound" x="panel._x + ((panel._width -180) / 2)" y="panel._y + ((panel._height - 80) / 2)" w="180" h="80" type="text"><![CDATA[]]></DIS>				<SCR name="finalTidyUp"><![CDATA[// set up page not found text boxtxtPageNotFound.beginFill(0xFFFFCC, 100);txtPageNotFound.lineStyle(1,0x000000,100);txtPageNotFound.drawRect(-10,-10,200,150,20);txtPageNotFound.dropShadow(7,45,0x999999,50);txtPageNotFound._visible = 0;// position and display the routing data if in development modeif (pageMode == "development"){  // must set properties after the icon routingInfo is defined in the project tree  routingInfo._x = routingInfoX;  routingInfo._y = routingInfoY;  routingInfo._visible = true;}else {  // hide routing info as this is live usage   routingInfo._visible = false;}// disable current tab to prevent second use whilst current  icon.parentNode.clip().setEnabled(false);    ]]></SCR>			</RES>			<RES name="initialise" type="event" eventName="onLoad" icon="initButton" erase="1" exit="0">				<INT name="wait" perpetual="0">					<RES name="initButton" type="timeLimit" secs="0" reset="0" erase="1" exit="0">						<SCR name="activatePaneOne"><![CDATA[// ensure first tab is enabled even if there is only one tabif (itemCount > 1){  btn1.swfFile.onRelease();} else {  initButton.swfFile.onRelease();}]]></SCR>					</RES>				</INT>			</RES>		</INT>	</PG>