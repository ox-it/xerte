	<PG title="Custom Hotspots" repeat="1" w="txt._width" y="txt._y + txt._height + 60" x="txt._x" name="customHotspots">		<SCR name="getPageID"><![CDATA[pageIcon = icon.parentNode.clip();if (rootIcon.projMode == "dev"){   // Page Wizard  pageIcon.templateData = pageIcon.extXML.toObject();  pageIcon.templateData = pageIcon.templateData.pageWizard[0];} else {  // Toolkits  myXML = new XML(extXML.firstChild.childNodes[rootIcon.getPageIndex() - pgOffset]);  pageIcon.templateData = myXML.toObject();}  rootIcon.setTitleText(templateData.learningObject[0].name);  // handle multiple page data definitions in a project if (rootIcon.projectPageIndex == undefined){     rootIcon.projectPageIndex = 0;}// check if this page has a definition for the current project index and default to 0 if notif (pageIcon.templateData.customHotspots[rootIcon.projectPageIndex].name == undefined){  projPI = 0;} else {  projPI = rootIcon.projectPageIndex; }      hicol = pageIcon.templateData.customHotspots[projPI].hicol;// set up text stringsif (pageIcon.templateData.customHotspots[projPI].hotspotsTxt != undefined){  hotspotsTxt = pageIcon.templateData.customHotspots[projPI].hotspotsTxt;} else {  hotspotsTxt = "Explore the diagram. Click on the various parts to learn more.";}if (pageIcon.templateData.customHotspots[projPI].labelsTxt != undefined){  labelsTxt = pageIcon.templateData.customHotspots[projPI].labelsTxt;} else {  labelsTxt = "Drag the pins for each label to the correct position in the diagram. You can re-position the labels if required.";}if (pageIcon.templateData.customHotspots[projPI].showMeTxt != undefined){  showMeTxt = pageIcon.templateData.customHotspots[projPI].showMeTxt;} else {  showMeTxt = "Use the arrows to learn more.";}if (pageIcon.templateData.customHotspots[projPI].regionsTxt != undefined){  regionsTxt = pageIcon.templateData.customHotspots[projPI].regionsTxt;} else {  regionsTxt = "Show Regions";}if (pageIcon.templateData.customHotspots[projPI].nextTxt != undefined){  nextTxt = pageIcon.templateData.customHotspots[projPI].nextTxt;} else {  nextTxt = "Next";}if (pageIcon.templateData.customHotspots[projPI].priorTxt != undefined){  priorTxt = pageIcon.templateData.customHotspots[projPI].priorTxt;} else {  priorTxt = "Back";}if (pageIcon.templateData.customHotspots[projPI].nextBtnTxt != undefined){  nextBtnTxt = pageIcon.templateData.customHotspots[projPI].nextBtnTxt;} else {  nextBtnTxt = "Next";}if (pageIcon.templateData.customHotspots[projPI].nextBtnTip != undefined){  nextBtnTip = pageIcon.templateData.customHotspots[projPI].nextBtnTip;} else {  nextBtnTip = "Next Question";}if (pageIcon.templateData.customHotspots[projPI].nextBtnWidth != undefined){  nextBtnWidth = pageIcon.templateData.customHotspots[projPI].nextBtnWidth;} else {  nextBtnWidth = "100";}if (pageIcon.templateData.customHotspots[projPI].checkBtnTxt != undefined){  checkBtnTxt = pageIcon.templateData.customHotspots[projPI].checkBtnTxt;} else {  checkBtnTxt = "Check";}if (pageIcon.templateData.customHotspots[projPI].checkBtnTip != undefined){  checkBtnTip = pageIcon.templateData.customHotspots[projPI].checkBtnTip;} else {  checkBtnTip = "Check Answer";}if (pageIcon.templateData.customHotspots[projPI].checkBtnWidth != undefined){  checkBtnWidth = pageIcon.templateData.customHotspots[projPI].checkBtnWidth;} else {  checkBtnWidth = "100";}if (pageIcon.templateData.customHotspots[projPI].beforeQuesCount != undefined){  beforeQuesCount = pageIcon.templateData.customHotspots[projPI].beforeQuesCount;} else {  beforeQuesCount = "Question";}if (pageIcon.templateData.customHotspots[projPI].nQValue != undefined){  nQValue = pageIcon.templateData.customHotspots[projPI].nQValue;} else {  nQValue = "n";}if (pageIcon.templateData.customHotspots[projPI].betweenQuesCount != undefined){  betweenQuesCount = pageIcon.templateData.customHotspots[projPI].betweenQuesCount;} else {  betweenQuesCount = "of";}if (pageIcon.templateData.customHotspots[projPI].afterQuesCount != undefined){  afterQuesCount = pageIcon.templateData.customHotspots[projPI].afterQuesCount;} else {  afterQuesCount = "";}if (pageIcon.templateData.customHotspots[projPI].questionTxt != undefined){  questionTxt = pageIcon.templateData.customHotspots[projPI].questionTxt;} else {  questionTxt = "Which item is highlighted in the diagram? Choose from the following options";}if (pageIcon.templateData.customHotspots[projPI].wrong1stTxt != undefined){  wrong1stTxt = pageIcon.templateData.customHotspots[projPI].wrong1stTxt;} else {  wrong1stTxt = "No. The";}if (pageIcon.templateData.customHotspots[projPI].wrong2ndTxt != undefined){  wrong2ndTxt = pageIcon.templateData.customHotspots[projPI].wrong2ndTxt;} else {  wrong2ndTxt = "is highlighted in green. The correct answer is the";}if (pageIcon.templateData.customHotspots[projPI].noOptionTxt != undefined){  noOptionTxt = pageIcon.templateData.customHotspots[projPI].noOptionTxt;} else {  noOptionTxt = "k You haven't selected an option.";}if (pageIcon.templateData.customHotspots[projPI].correctTxt != undefined){  correctTxt = pageIcon.templateData.customHotspots[projPI].correctTxt;} else {  correctTxt = "That's right.";}if (pageIcon.templateData.customHotspots[projPI].continueTxt != undefined){  continueTxt = pageIcon.templateData.customHotspots[projPI].continueTxt;} else {  continueTxt = "Move on to the next question";}if (pageIcon.templateData.customHotspots[projPI].scoreLabel != undefined){  scoreLabel = pageIcon.templateData.customHotspots[projPI].scoreLabel;} else {  scoreLabel = "Score";}if (pageIcon.templateData.customHotspots[projPI].beforeScore != undefined){  beforeScore = pageIcon.templateData.customHotspots[projPI].beforeScore;} else {  beforeScore = "You scored";}if (pageIcon.templateData.customHotspots[projPI].nSValue != undefined){  nSValue = pageIcon.templateData.customHotspots[projPI].nSValue;} else {  nSValue = "s";}if (pageIcon.templateData.customHotspots[projPI].betweenScore != undefined){  betweenScore = pageIcon.templateData.customHotspots[projPI].betweenScore;} else {  betweenScore = "out of";}if (pageIcon.templateData.customHotspots[projPI].afterScore != undefined){  afterScore = pageIcon.templateData.customHotspots[projPI].afterScore;} else {  afterScore = "in the quiz";}if (pageIcon.templateData.customHotspots[projPI].onCompletion != undefined){  onCompletion = pageIcon.templateData.customHotspots[projPI].onCompletion;} else {  onCompletion = "You can retake the quiz at any time";}if (pageIcon.templateData.customHotspots[projPI].restart != undefined){  restart = pageIcon.templateData.customHotspots[projPI].restart;} else {  restart = "Restart";}// end of text string setupif (pageIcon.templateData.customHotspots[projPI].narration != undefined){  narration = pageIcon.templateData.customHotspots[projPI].narration;  rootIcon.broadcast('showAudio');}]]></SCR>		<DIS h="474" w="760" tabIndex="-1" id="panel" name="panel" x="20" y="20" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<DRW id="draw" name="drawing" x="40" y="40"><![CDATA[]]></DRW>		<SCR name="setData"><![CDATA[draw.setData(pageIcon.templateData.customHotspots[projPI]);draw.allowShapeEvents();hCol = pageIcon.templateData.customHotspots[projPI].highlightColour;lw = pageIcon.templateData.customHotspots[projPI].lineWidth;//prepare to draw the shapesif (pageIcon.templateData.customHotspots[projPI].showShapes == 'true'){  shapesHighlight = true;  shapeAlpha = 100;} else {  shapeAlpha = 0;  shapesHighlight = false;}//which typeif (pageIcon.templateData.customHotspots[projPI].interactivity == 'Hotspots'){  intType = 0;}if (pageIcon.templateData.customHotspots[projPI].interactivity == 'Labels'){  intType = 1;}if (pageIcon.templateData.customHotspots[projPI].interactivity == 'Show Me'){  intType = 2;}if (pageIcon.templateData.customHotspots[projPI].interactivity == 'MCQ'){  intType = 3;  shapeAlpha = 0;  shapesHighlight = false;  icon.parentNode.getChildByName("showShapes").removeNode();}for (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image' && draw.shapes[i].type != 'line'){    draw.shapes[i].refreshShape(lw,hCol,shapeAlpha,0,0);  }}]]></SCR>		<DIS textColour="#333333" id="txt" name="text" x="500" y="40" w="260" h="10" type="text"><![CDATA[{pageIcon.templateData.customHotspots[projPI].text}]]></DIS>		<DIS textColour="#333333" id="fb" name="fb" x="txt._x" y="txt._y + txt._height + 20" w="260" h="10" type="text"><![CDATA[]]></DIS>		<INT name="showShapes" perpetual="1">			<RES name="onLoadImage" type="event" eventName="onLoadImage" icon="draw" erase="1" exit="0">				<INT id="shaper" name="showShapes" perpetual="1">					<RES rs="chkShapes" name="toggle" type="checkBox" x="40" y="25" label="{regionsTxt}" erase="1" exit="0">						<SCR name="showShapes"><![CDATA[if (shapesHighlight == true){  shapesHighlight = false;  shapeAlpha = 0;} else {  shapeAlpha = 100;  shapesHighlight = true;}for (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image' && draw.shapes[i].type != 'line'){    draw.shapes[i].refreshShape(lw,hCol,shapeAlpha,0,0);  }}]]></SCR>					</RES>				</INT>			</RES>		</INT>		<SCR name="setCheckBox"><![CDATA[if (shapesHighlight == true){  chkShapes.setCheckState(true);}]]></SCR>		<FW id="interactions" name="interactions">			<FW_ENT name="navigate">				<INT name="navigate" perpetual="0">					<RES name="0secs" type="timeLimit" secs="0" reset="0" erase="1" exit="0">						<SCR name="gotoPage"><![CDATA[interactions.gotoPage(intType);]]></SCR>					</RES>				</INT>			</FW_ENT>			<PG name="hotspots">				<DIS textColour="#333333" name="instructions" x="40" y="474" w="760" h="10" type="text"><![CDATA[{'<font size="10"><b>' + hotspotsTxt + '</b></font>'}]]></DIS>				<SCR name="makeAccessible"><![CDATA[draw.makeAccessible();]]></SCR>				<INT name="interaction" perpetual="0">					<RES name="onShapeRelease" type="event" eventName="onShapeRelease" icon="draw" erase="1" exit="0">						<SCR name="highlightInfo"><![CDATA[//hide previousfor (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image'){    draw.shapes[i].refreshShape(lw,hCol,shapeAlpha,hCol,0);  }}draw.currentShape._alpha = 100;draw.currentShape.refreshShape(lw,hCol,100,hCol,40);//find any other shapes in this groupgrp = draw.currentShape.group;if (grp != ''){    for (i = 0; i < draw.shapes.length; i++){    if (draw.shapes[i].group == grp){      draw.shapes[i].refreshShape(lw,hCol,100,hCol,40);    }  }}fb.setText('<b>' + draw.currentShape.label + '</b><br>' + draw.currentShape.info);]]></SCR>						<SCR name="clear"><![CDATA[if (draw.currentShape.info != ''){  fb.beginFill(0xFFFFCC,100);  fb.lineStyle(1,0x333333,100);  fb.drawRect(0,0,260,474 - fb._y);}]]></SCR>					</RES>				</INT>			</PG>			<PG name="dragDropLabels">				<DIS textColour="#333333" name="instructions" x="40" y="474" w="760" h="10" type="text"><![CDATA[{'<font size="10"><b>' + labelsTxt + '</b></font>'}]]></DIS>				<SCR name="makeLabels"><![CDATA[//only create one label for each group, so keep track of group namesgroups = new Object();labels = new Array();for (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image' && draw.shapes[i].type != 'line'){// && draw.shapes[i].label != ""){        addShape = true;    //we have shape - in a group?    if (draw.shapes[i].group != ''){      if (groups[draw.shapes[i].group] == undefined){ //we dont have this group yet        groups[draw.shapes[i].group] = true;      } else {        addShape = false;      }    }       if (addShape == true){      temp = new Object();        temp.label = draw.shapes[i].label;      temp.info = draw.shapes[i].info;      temp.shape = draw.shapes[i];      temp.group = draw.shapes[i].group;      labels.push(temp);    }  }}//create the interactionsif (icon.built != true){  icon.nextSibling.firstChild.duplicate(labels.length - 1);  icon.built = true;}]]></SCR>				<DEC id="mainDec" name="labels" repeat="all" branch="sequence" pause="0" erase="0" eraseOnExit="0">					<PG name="labels">						<DIS textColour="#333333" id="protoLabel" name="protoLabel" x="40 + Math.floor(icon.parentNode.index() % 4) * 180" y="390 + Math.floor(icon.parentNode.index() / 4) * 30" w="150" h="10" type="text"><![CDATA[{labels[icon.parentNode.index()].label}]]></DIS>						<DIS id="protoFlag" name="protoPin" x="protoLabel._x + 150" y="protoLabel._y" type="ext" url="templatePath + 'common/pin_blue.png'"><![CDATA[]]></DIS>						<SCR name="setup"><![CDATA[tempPG = icon.parentNode.clip();tempPG.label = protoLabel;tempPG.flag = protoFlag;protoLabel.beginFill(0x858585,100);protoLabel.drawRect(-1,-1,152,protoLabel._height + 2,3);protoLabel.beginFill(0xFFFFFF,100);protoLabel.drawRect(0,0,150,protoLabel._height,3);protoLabel.dropShadow(2,45,0x666666,100);protoFlag.makeDraggable(true, 0,0,800,514);protoLabel.makeDraggable(true, 0,0,800,514);protoLabel.group = labels[icon.parentNode.index()].group;nextY = protoLabel._y + protoLabel._height + 5]]></SCR>						<INT name="dragDropHandlers" perpetual="1">							<RES name="protoFlagStartDrag" type="event" eventName="onStartDrag" icon="protoFlag" erase="1" exit="0">								<SCR name="start"><![CDATA[tempPG = mainDec.pages[mainDec.getPageIndex()];]]></SCR>							</RES>							<RES name="protoFlagDrag" type="event" eventName="onDrag" icon="protoFlag" erase="1" exit="0">								<SCR name="update"><![CDATA[tempPG.clear();tempPG.lineStyle(lw,hCol,100);tempPG.moveTo(tempPG.flag._x + 8, tempPG.flag._y + 8);tempPG.lineTo(tempPG.label._x + tempPG.label._width / 2, tempPG.label._y + 5);]]></SCR>							</RES>							<RES name="protoFlagStopDrag" type="event" eventName="onStopDrag" icon="protoFlag" erase="1" exit="0">								<SCR name="stop"><![CDATA[//useful thingstempPG = mainDec.pages[mainDec.getPageIndex()];tempIC = tempPG.flag;tempLabel = tempPG.label;//did we hit a shape...success = false;for (i = 0; i < draw.shapes.length; i++){  //way around problems with hittest and the third param for shape outline if scalemode is not default  if (Stage.scaleMode == 'noScale'){    hit = draw.shapes[i].hitTest(tempIC._x + 8, tempIC._y + 8 + 64, true);  } else {    hit = draw.shapes[i].hitTest(tempIC);  }   if (hit == true){    if (draw.shapes[i].label == tempLabel.txt.text){       shapeIndex = i;       success = true;       break;    }        if (draw.shapes[i].group == tempLabel.group && tempLabel.group != ''){       shapeIndex = i;       success = true;       break;    }  }}//un-highlight other shapesfor (i = 0; i < draw.shapes.length; i++){  draw.shapes[i].refreshShape(lw,hCol,shapeAlpha,0,0);}if (success != true){ //replace  tempPG.clear();  tempIC._x = tempLabel._x + 150;  tempIC._y = tempLabel._y;  tempPG.matched = false;} else {  //save the info  tempPG.info = draw.shapes[shapeIndex].info;  //highlight it  draw.shapes[shapeIndex]._alpha = 100;  draw.shapes[shapeIndex].refreshShape(lw,hCol,100,hCol,40);    //find any other shapes in this group    grp = draw.shapes[shapeIndex].group;  if (grp != ''){      for (i = 0; i < draw.shapes.length; i++){      if (draw.shapes[i].group == grp){        draw.shapes[i].refreshShape(lw,hCol,100,hCol,40);      }    }  }  //set info  fb.setText('<b>' + tempLabel.txt.text + '</b><br>' + tempPG.info);  fb.beginFill(0xFFFFCC,100);  fb.lineStyle(1,0x333333,100);  fb.drawRect(0,0,260,384 - fb._y);  //flag for info  tempPG.matched = true;}]]></SCR>							</RES>							<RES name="protoLabelStartDrag" type="event" eventName="onStartDrag" icon="protoLabel" erase="1" exit="0">								<SCR name="start"><![CDATA[tempPG = mainDec.pages[mainDec.getPageIndex()];tempLabel = tempPG.label;if (tempPG.matched == true){  //un-highlight other shapes  for (i = 0; i < draw.shapes.length; i++){    draw.shapes[i].refreshShape(0,0,0,0,0);  }  //highlight it  labels[mainDec.getPageIndex()].shape._alpha = 100;  labels[mainDec.getPageIndex()].shape.refreshShape(lw,hCol,100,hCol,40);    //find any other shapes in this group    grp = labels[mainDec.getPageIndex()].shape.group;  if (grp != ''){      for (i = 0; i < draw.shapes.length; i++){      if (draw.shapes[i].group == grp){        draw.shapes[i].refreshShape(lw,hCol,100,hCol,40);      }    }  }  fb.setText('<b>' + tempLabel.txt.text + '</b><br>' + tempPG.info);  fb.lineStyle(0,0x}]]></SCR>							</RES>							<RES name="protoLabelDrag" type="event" eventName="onDrag" icon="protoLabel" erase="1" exit="0">								<SCR name="update"><![CDATA[if (tempPG.matched == true){  tempPG.clear();  tempPG.lineStyle(lw,hCol,100);  tempPG.moveTo(tempPG.flag._x + 8, tempPG.flag._y + 8);  tempPG.lineTo(tempPG.label._x + tempPG.label._width / 2, tempPG.label._y + 5);} else {  tempPG.clear();  tempPG.flag._x = tempPG.label._x+150;  tempPG.flag._y = tempPG.label._y;}]]></SCR>							</RES>							<RES name="protoLabelStopDrag" type="event" eventName="onStopDrag" icon="protoLabel" erase="1" exit="0">								<SCR name="stop"><![CDATA[tempPG = mainDec.pages[mainDec.getPageIndex()];tempLabel = tempPG.label;]]></SCR>							</RES>							<RES name="protoFlagSetFocus" type="event" eventName="onSetFocus" icon="protoFlag" erase="1" exit="0">								<SCR name="[Untitled]"><![CDATA[debug("GOT IT");]]></SCR>							</RES>						</INT>					</PG>				</DEC>				<INT name="stop" perpetual="0" />			</PG>			<PG name="showMe">				<DIS textColour="#333333" name="instructions" x="90" y="460" w="760" h="10" type="text"><![CDATA[{'<font size="10"><b>' + showMeTxt + '</b></font>'}]]></DIS>				<SCR name="setup"><![CDATA[//only create one label for each group, so keep track of group namesgroups = new Object();labels = new Array();for (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image' && draw.shapes[i].type != 'line'){// && draw.shapes[i].label != ""){        addShape = true; //a flag        //we have shape - in a group?    if (draw.shapes[i].group != ''){      if (groups[draw.shapes[i].group] == undefined){ //we dont have this group yet        groups[draw.shapes[i].group] = true;      } else {        addShape = false; //we know about this group already      }    }       if (addShape == true){      temp = new Object();        temp.label = draw.shapes[i].label;      temp.info = draw.shapes[i].info;      temp.shape = draw.shapes[i];      temp.group = draw.shapes[i].group;      labels.push(temp);    }  }}acIndex = 0;]]></SCR>				<INT name="interaction" perpetual="0">					<RES toolTip="{priorTxt}" swf="templatePath + 'common/leftButton.swf'" name="back" type="button" x="40" y="460" label="{priorTxt}" erase="1" exit="0">						<SCR name="showPrev"><![CDATA[acIndex--;if (acIndex == -1){  acIndex = labels.length - 1;}//hide previousfor (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image'){    draw.shapes[i].refreshShape(lw,hCol,shapeAlpha,hCol,0);  }}labels[acIndex].shape.alpha = 100;labels[acIndex].shape.refreshShape(lw,hCol,100,hCol,40);//find any other shapes in this groupgrp = labels[acIndex].group;if (grp != ''){  for (i = 0; i < draw.shapes.length; i++){    if (draw.shapes[i].group == grp){      draw.shapes[i].refreshShape(lw,hCol,100,hCol,40);    }  }}fb.setText('<b>' + labels[acIndex].shape.label + '</b><br>' + labels[acIndex].shape.info);fb.beginFill(0xFFFFCC,100);fb.lineStyle(1,0x333333,100);fb.drawRect(0,0,260,474 - fb._y);]]></SCR>					</RES>					<RES toolTip="{nextTxt}" swf="templatePath + 'common/rightButton.swf'" name="next" type="button" x="65" y="460" label="{nextTxt}" erase="1" exit="0">						<SCR name="showNext"><![CDATA[acIndex++;if (acIndex == labels.length){  acIndex = 0;}//hide previousfor (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image'){    draw.shapes[i].refreshShape(lw,hCol,shapeAlpha,hCol,0);  }}labels[acIndex].shape.alpha = 100;labels[acIndex].shape.refreshShape(lw,hCol,100,hCol,40);//find any other shapes in this groupgrp = labels[acIndex].group;if (grp != ''){    for (i = 0; i < draw.shapes.length; i++){    if (draw.shapes[i].group == grp){      draw.shapes[i].refreshShape(lw,hCol,100,hCol,40);    }  }}fb.setText('<b>' + labels[acIndex].shape.label + '</b><br>' + labels[acIndex].shape.info);fb.beginFill(0xFFFFCC,100);fb.lineStyle(1,0x333333,100);fb.drawRect(0,0,260,474 - fb._y);]]></SCR>					</RES>				</INT>			</PG>			<PG name="MCQ">				<SCR name="hideShapes"><![CDATA[//hide the shapesfor (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image' && draw.shapes[i].type != 'line'){    draw.shapes[i]._alpha = 0;  }}]]></SCR>				<SCR name="makeQuestions"><![CDATA[labels = new Array();for (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image' && draw.shapes[i].type != 'line'){// && draw.shapes[i].label != ""){    temp = new Object();    temp.label = draw.shapes[i].label;    temp.info = draw.shapes[i].info;    temp.shape = draw.shapes[i];    labels.push(temp);  }}//create the interactionsif (icon.built != "true"){  icon.nextSibling.firstChild.duplicate(labels.length - 1);  icon.built = "true";}score = 0;count = 0;]]></SCR>				<DEC id="quizDec" name="questions" repeat="all" branch="randomUnused" pause="0" erase="1" eraseOnExit="1">					<PG name="protoQuestion">						<DIS id="orient" name="orient" x="txt._x" y="txt._y + txt._height + 20" w="400" h="10" type="text"><![CDATA[]]></DIS>						<DIS id="feedback" name="feedback" x="txt._x" y="txt._y + txt._height + 60" w="txt._width" h="10" type="text"><![CDATA[]]></DIS>						<SCR name="highlightShape"><![CDATA[// set up orient text// {'<b>Question ' + quizDec.repCount + ' of ' + labels.length + '</b>'}if (nQValue == "n"){  // number preceeds count  orientText = "<b>" + beforeQuesCount + " " + quizDec.repCount + " " + betweenQuesCount + " " + labels.length + " " + afterQuesCount + "</b>"} else {  // count preceeds number  orientText = "<b>" + beforeQuesCount + " " + labels.length + " " + betweenQuesCount + " " + quizDec.repCount + " " + afterQuesCount + "</b>"}orient.setText(orientText);//hide the shapesfor (i = 0; i < draw.shapes.length; i++){  if (draw.shapes[i].type != 'image' && draw.shapes[i].type != 'line'){    draw.shapes[i]._alpha = 0;  }}count++;q = icon.parentNode.index();labels[q].shape._alpha = 100;labels[q].shape.refreshShape(lw,hCol,100,lc,40);//add the right answer and 3 wrong answers to the question, randomlyanswersArray = new Array();answersArray.push(labels[q].label);noOptions = 4;uniqueLabels = new Array();for (i=0; i<labels.length; i++) {  if (uniqueLabels.findValue(labels[i].label) == -1){      uniqueLabels.push(labels[i].label);  }}if (uniqueLabels.length < noOptions) {  optionsToDelete = noOptions - uniqueLabels.length;  for (i=0; i<optionsToDelete; i++) {    icon.nextSibling.childNodes[uniqueLabels.length+1].removeNode();  }  noOptions = uniqueLabels.length;}while (answersArray.length < noOptions){  randomIndex = Math.floor(Math.random() * labels.length);  randomTerm = labels[randomIndex].label;  if (answersArray.findValue(randomTerm) == -1){    answersArray.push(randomTerm);  }}answersArray.randomize();//mark the right answer as correctfor (i = 0; i < answersArray.length; i++){  if (answersArray[i] == labels[q].label){    icon.nextSibling.childNodes[i + 1].attributes.correct = 1;  } else {    icon.nextSibling.childNodes[i + 1].attributes.correct = 0;  }}option = "";]]></SCR>						<INT id="mcq" name="interaction" perpetual="0">							<RES name="prompt" type="label" x="txt._x" y="txt._y + txt._height + 40" w="txt._width" h="10" text="{questionTxt}" />							<RES rs="op1" correct="0" name="option1" type="radio" x="icon.previousSibling.clip()._x" y="_ytile + 20" label="{answersArray[0]}" group="grp" erase="1" exit="0">								<SCR name="getOption"><![CDATA[option = answersArray[0];]]></SCR>							</RES>							<RES rs="op2" name="option2" correct="0" type="radio" x="icon.previousSibling.clip()._x" y="_ytile + 10" label="{answersArray[1]}" group="grp" erase="1" exit="0">								<SCR name="getOption"><![CDATA[option = answersArray[1];]]></SCR>							</RES>							<RES rs="op3" correct="0" name="option3" type="radio" x="icon.previousSibling.clip()._x" y="_ytile + 10" label="{answersArray[2]}" group="grp" erase="1" exit="0">								<SCR name="getOption"><![CDATA[option = answersArray[2];]]></SCR>							</RES>							<RES rs="op4" correct="0" name="option4" type="radio" x="icon.previousSibling.clip()._x" y="_ytile + 10" label="{answersArray[3]}" group="grp" erase="1" exit="0">								<SCR name="getOption"><![CDATA[option = answersArray[3];]]></SCR>							</RES>							<RES toolTip="{checkBtnTip}" rs="btnCheck" swf="templatePath + 'common/button.swf'" name="check" type="button" x="icon.previousSibling.clip()._x" y="_ytile + 10" label="{checkBtnTxt}" erase="1" exit="0">								<SCR name="judge"><![CDATA[feedback._y = icon.parentNode.previousSibling.clip()._y + 60;  if (option != ""){    if (mcq.judge() == true){    feedback.setText(correctTxt + " " + continueTxt);    score++;      } else {      //highlight the option they selected //   feedback.setText("No. The " + option + " is highlighted green. The correct answer is the " + labels[q].label + ".<br><br>Move on to the next question.");    feedback.setText(wrong1stTxt + " " + option + " " + wrong2ndTxt + " " + labels[q].label + ".<br><br>" + continueTxt);    for (i = 0; i < labels.length; i++){      if (labels[i].label == option){        labels[i].shape._alpha = 100;        labels[i].shape.refreshShape(2,0x00FF00,100,0x00FF00,40);        break;      }    }  }  op1.setEnabled(false);  op2.setEnabled(false);  op3.setEnabled(false);  op4.setEnabled(false);  btnCheck.setEnabled(false);  btnNext.setEnabled(true);} else {//  feedback.setText("You haven't selected an option.");feedback.setText(noOptionTxt);}]]></SCR>							</RES>							<RES toolTip="{nextBtnTip}" rs="btnNext" enabled="0" swf="templatePath + 'common/button.swf'" name="moveOn" type="button" x="icon.previousSibling.clip()._x" y="454" label="{nextBtnTxt}" erase="1" exit="1">								<SCR name="next"><![CDATA[if (count == labels.length){  // set up final feedback text  quesCount = icon.parentNode.parentNode.parentNode.parentNode.childNodes.length;  if (nSValue = "s"){    // score preceeds number of questions    //{'<b>Score</b><br>You scored ' + score + ' out of ' + icon.previousSibling.childNodes.length + ' in the quiz. <br><br>You can retake the quiz at any time.'}        scorePhrase = "<b>" + scoreLabel + "</b><br>" + beforeScore + " " + score + " " + betweenScore + " " + quesCount + " " + afterScore +  "<br><br>" + onCompletion;  } else {    // number of questions preceeds score    scorePhrase = "<b>" + scoreLabel + "</b><br>" + beforeScore + " " + quesCount + " " + betweenScore + " " + score + " " + afterScore +  "<br><br>" + onCompletion;  }  quizDec.exit();}]]></SCR>							</RES>						</INT>					</PG>				</DEC>				<DIS id="fb" name="feedback" x="txt._x" y="txt._y + txt._height + 20" w="txt._width" h="10" type="text"><![CDATA[{scorePhrase}]]></DIS>				<INT name="restart" perpetual="0">					<RES swf="templatePath + 'common/button.swf'" toolTip="Enter Value..." name="Restart" type="button" x="txt._x" y="fb._y + fb._height + 20" label="{restart}" erase="1" exit="0">						<SCR name="refresh"><![CDATA[//refresh the pagerootIcon.gotoPage(rootIcon.currentPage);]]></SCR>					</RES>				</INT>			</PG>		</FW>	</PG>