	<PG title="Table" name="table">		<SCR name="getPageID"><![CDATA[pageIcon = icon.parentNode.clip();if (rootIcon.projMode == "dev"){   // Page Wizard  pageIcon.templateData = pageIcon.extXML.toObject();  pageIcon.templateData = pageIcon.templateData.pageWizard[0];} else {  // Toolkits  myXML = new XML(extXML.firstChild.childNodes[rootIcon.getPageIndex() - pgOffset]);  pageIcon.templateData = myXML.toObject();}  rootIcon.setTitleText(templateData.learningObject[0].name);  // handle multiple page data definitions in a project if (rootIcon.projectPageIndex == undefined){     rootIcon.projectPageIndex = 0;}// check if this page has a definition for the current project index and default to 0 if notif (pageIcon.templateData.table[rootIcon.projectPageIndex].name == undefined){  projPI = 0;} else {  projPI = rootIcon.projectPageIndex; }  // set up text stringsif (pageIcon.templateData.table[projPI].loadingPrompt != undefined){  loadingPrompt = pageIcon.templateData.table[projPI].loadingPrompt;} else {  loadingPrompt = "Loading table data...";}if (pageIcon.templateData.table[projPI].narration != undefined){  narration = pageIcon.templateData.table[projPI].narration;  rootIcon.broadcast('showAudio');}]]></SCR>		<DIS initObject="{_visible:false}" id="panel" h="474" w="420" tabIndex="-1" name="panel" x="360" y="20" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<INT name="loader" perpetual="0">			<RES name="onLoad" type="event" eventName="onLoad" icon="panel" erase="1" exit="1">				<SCR name="loaded"><![CDATA[// move on]]></SCR>			</RES>		</INT>		<DIS id="csv" name="csv" x="20" y="20" w="400" h="10" type="text"><![CDATA[{loadingPrompt}]]></DIS>		<SCR id="getTableData" name="getTableData"><![CDATA[// gets tableData from xml or csv filestableData = "";rowData = new Array();rowHeights = new Array();if (pageIcon.templateData.table[projPI].tableData[0].url != undefined) {  csv.readFile(expression(pageIcon.templateData.table[projPI].tableData[0].url, this));} else {  tableData = pageIcon.templateData.table[projPI].tableData[0].data;  icon.nextSibling.attributes.perpetual = 1;    // populates rowArray with arrays each holding cell data for each row  tempRowArray = tableData.split('||');  for (i=0; i<tempRowArray.length; i++) {    rowData.push(tempRowArray[i].split('|'));    rowHeights.push(0);  }}]]></SCR>		<INT name="csvLoader" perpetual="0">			<RES name="onReadFile" type="event" eventName="onReadFile" icon="csv" erase="1" exit="1">				<SCR name="getCSVdata"><![CDATA[tableData = csv.fileData;tempRowArray = tableData.split('\n');for (i=0; i<tempRowArray.length; i++) {  rowData.push(tempRowArray[i].split(','));  rowHeights.push(0);}]]></SCR>			</RES>		</INT>		<SCR id="setUpTable" name="setUpTable"><![CDATA[// creates table rows once tableData loaded// duplicates correct number of rows & cells on each rowif (icon.attributes.built != 'true'){  icon.parentNode.getChildByName('tableClips').getChildByName('protoRow').firstChild.firstChild.duplicate(rowData[0].length - 1);  icon.parentNode.getChildByName('tableClips').getChildByName('protoRow').duplicate(rowData.length - 1);  icon.attributes.built = 'true';}// works out x y w h for text & table panel - these may change once data added// default positions with text on left and medium table sizetextX = 20;textY = 20;textW = 320;textH = 480;tableSize = pageIcon.templateData.table[projPI].tableData[0].size;textPos = pageIcon.templateData.table[projPI].align;if (tableSize == "small") {  textW = 520;  panel._width = 220;} else if (tableSize == "large") {  if (textPos != "bottom") {    textPos = "top"; // text forced to top  }  panel._width = 760;} else if (tableSize == "full screen") {  icon.parentNode.getChildByName('mainText').removeNode();  panel._width = 760;  panel._height = 974;  panel._x = 20;}if (tableSize != "full screen") {  if (textPos == "left") {    panel._x = textX + textW + 20;      } else if (textPos == "right") {    textX = panel._width + 40;    panel._x = 20;      } else if (textPos == "top") {    textW = 760;    textH = 200;    panel._x = (800 - panel._width) / 2;    panel._y = 240;    panel._height = 260;      } else if (textPos == "bottom") {    textW = 760;    textH = 200;    textY = 300;    panel._x = (800 - panel._width) / 2;    panel._y = 20;    panel._height = 260;  }}tableHeight = 0;tableWidth = panel._width-20;cellWidth = Math.round(tableWidth/rowData[0].length);]]></SCR>		<DEC id="tableClips" name="tableClips" repeat="all" branch="sequence" pause="0" erase="0" eraseOnExit="0">			<PG name="tableBits">				<DIS initObject="{_visible:false}" id="title" name="title" x="panel._x" y="panel._y + 10" w="panel._width" h="20" type="text"><![CDATA[{'<b><p align="center">' + pageIcon.templateData.table[projPI].tableData[0].name + '</p></b>'}]]></DIS>				<DIS toolTip="{pageIcon.templateData.table[projPI].tableData[0].alt}" url="FileLocation + " h="10" w="10" id="borders" name="borders" x="panel._x + 10" y="pageIcon.templateData.table[projPI].tableData[0].name !=  '' ? title._y + title._height + 10 : title._y" type="ext"><![CDATA[]]></DIS>				<DIS id="footnote" initObject="{_visible:false}" name="footnote" x="panel._x + 10" y="panel._y + panel._height" w="panel._width" h="10" type="text"><![CDATA[{pageIcon.templateData.table[projPI].tableData[0].caption}]]></DIS>			</PG>			<PG name="protoRow">				<DEC id="cells" name="cells" repeat="all" branch="sequence" pause="0" erase="0" eraseOnExit="0">					<PG name="protoCell">						<SCR name="styleCellTxt"><![CDATA[// text is bold if row is header or footermyRow = icon.parentNode.parentNode.parentNode;myInfo = rowData[myRow.index()-1][icon.parentNode.index()];header = pageIcon.templateData.table[projPI].tableData[0].header;if ((myRow.index()-1 == 0 && (header == 'header' || header == 'both')) || myRow.index()-1 == myRow.parentNode.childNodes.length - 2 && (header == 'footer' || header == 'both')) {  myInfo = '<b>' + myInfo + '</b>';}cellHeight = 0;for (i=0; i<myRow.index()-1; i++) {  cellHeight += rowHeights[i];}if (icon.parentNode.index() == 0) {  myRow.clip()._visible = false;}]]></SCR>						<DIS name="text" x="(cellWidth*icon.parentNode.index()) + borders._x + 5" y="cellHeight + borders._y + 5" w="cellWidth - 10" h="10" type="text"><![CDATA[{myInfo}]]></DIS>						<SCR name="calcRowHeight"><![CDATA[// row height should accomodate largest cell text in the rowif (rowHeights[myRow.index()-1] < icon.parentNode.getChildByName('text').clip()._height) {  rowHeights.splice(myRow.index()-1, 1, icon.parentNode.getChildByName('text').clip()._height+10);}if (icon.parentNode.index() == icon.parentNode.parentNode.childNodes.length - 1) {  tableHeight += rowHeights[myRow.index()-1];}]]></SCR>					</PG>				</DEC>			</PG>		</DEC>		<SCR name="setUpBorders"><![CDATA[// finishes table once all the data is in it// draw borders, cell shading & calculates cell sizes & positionsborderColour = '0x999999';borderStyle = pageIcon.templateData.table[projPI].tableData[0].borders;shadeHeader = pageIcon.templateData.table[projPI].tableData[0].shadeHeader;// shade and underline header rowheader = pageIcon.templateData.table[projPI].tableData[0].header;if (header == 'header' || header == 'both') {  if (shadeHeader == 'true') {    borders.lineStyle(1, borderColour, 0);    borders.beginFill(0xF2F2F2, 100);    borders.drawRect(1, 0, tableWidth-2, rowHeights[0]);    borders.endFill();  }  if (borderStyle == 'simple') {    borders.lineStyle(1, borderColour, 100);    borders.moveTo(0, rowHeights[0]);    borders.lineTo(tableWidth, rowHeights[0]);  }}// shade alternate rows - start shading with 2nd row (or 3rd if there's a header row)for (i=0; i<rowData.length; i++) {  if (pageIcon.templateData.table[projPI].tableData[0].shade == 'true') {    num = i;    if ((header == 'header' || header == 'both') && shadeHeader == 'true') {      num -= 1;    }    if (num % 2 != 0) {      if (num > 0 && (header == 'none' || header == 'header' || (i != rowData.length-1 || shadeHeader == 'false'))) {        borders.lineStyle(1, borderColour, 0);        borders.beginFill(0xE3FFD6, 100);        borders.drawRect(1, rowHeights.sumTo(i), tableWidth-2, rowHeights[i]);        borders.endFill();      }    }  }}// shade and draw line above footer rowif (header == 'footer' || header == 'both') {    if (shadeHeader == 'true') {    borders.lineStyle(1, borderColour, 0);    borders.beginFill(0xF2F2F2, 100);    borders.drawRect(1, rowHeights.sumTo(rowData.length-1), tableWidth-2, rowHeights[rowData.length-1]);    borders.endFill();  }  if (borderStyle == 'simple') {    borders.lineStyle(1, borderColour, 100);    borders.moveTo(0, rowHeights.sumTo(rowData.length-1));    borders.lineTo(tableWidth, rowHeights.sumTo(rowData.length-1));  }}// outside vertical borders around whole tableif (borderStyle == 'full' || borderStyle == 'outside') {  borders.lineStyle(1, borderColour, 100);  borders.moveTo(0, 0);  borders.lineTo(tableWidth, 0);  borders.lineTo(tableWidth, tableHeight);  borders.lineTo(0, tableHeight);  borders.lineTo(0, 0);}// outside top & bottom horizontal linesif (borderStyle == 'simple') {  borders.lineStyle(2, borderColour, 100);  borders.moveTo(0, 0);  borders.lineTo(tableWidth, 0);  borders.moveTo(0, tableHeight);  borders.lineTo(tableWidth, tableHeight);}// vertical lines between columnsif (borderStyle == 'vertical' || borderStyle == 'full') {  for (i=0; i<rowData[0].length; i++) {    if (i != rowData[0].length-1) {      borders.lineStyle(1, borderColour, 100);      borders.moveTo(cellWidth*(i+1), 0);      borders.lineTo(cellWidth*(i+1), tableHeight);    }  }}// horizontal lines between rowsif (borderStyle == 'horizontal' || borderStyle == 'full') {  lineY = 0;  for (i=0; i<rowData.length; i++) {    if (i != rowData.length-1) {      lineY += rowHeights[i];      borders.lineStyle(1, borderColour, 100);      borders.moveTo(0, lineY);      borders.lineTo(tableWidth, lineY);    }  }}// makes space on panel for captionif (pageIcon.templateData.table[projPI].tableData[0].caption != undefined) {  panel._height = (borders._y - title._y) + tableHeight + footnote._height + 30;  footnote._y = panel._y + panel._height - footnote._height - 10;  footnote._visible = true;} else {  panel._height = (borders._y - title._y) + tableHeight + 20;}if (textPos == 'bottom') {  textY = panel._y + panel._height + 20;  textH = 500 - textY;}// make text area smaller if table won't fit onheightDif = 0;if (textPos == 'top' && (panel._y + panel._height) > 515) {  if (500 - panel._height - 40 < 40) {    heightDif = textH - 40;    textH = 40;  } else {    heightDif = textH - (500 - panel._height - 30);    textH = 500 - panel._height - 30;    }}]]></SCR>		<DIS id="mainText" scrolling="auto" name="mainText" x="textX" y="textY" w="textW" h="textH" type="text"><![CDATA[{pageIcon.templateData.table[projPI].text}]]></DIS>		<SCR name="finishLayout"><![CDATA[// table moved up if space availiableif (textPos == 'top' && (mainText._height < textH || heightDif != 0)) {  heightDif = panel._y - (mainText._height + mainText._y + 10);  panel._y -= heightDif;  tableClips._y -= heightDif;}// everything made visible now laid out correctlycsv.setText("");panel._visible = true;title._visible = true;for (i=0; i<icon.parentNode.getChildByName('tableClips').childNodes.length-1; i++) {  icon.parentNode.getChildByName('tableClips').childNodes[i+1].clip()._visible = true;}]]></SCR>	</PG>