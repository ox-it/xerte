	<PG title="Scenario" name="scenario">		<SCR name="getPageID"><![CDATA[/** I set up the xml data and establish the type of container the page is in* Audio narration of the scenario is also triggered from this page*/ pageIcon = icon.parentNode.clip();if (rootIcon.projMode == "dev"){// Page Wizard   pageIcon.templateData = pageIcon.extXML.toObject();  pageIcon.templateData = pageIcon.templateData.pageWizard[0];    // routed pages only  pageID_array = new Array();  pageTitle_array = new Array();    for (i = 0; i < rootIcon.pages.length; i++){    pageID_array.push(rootIcon.pages[i].extXML.firstChild.childNodes[0].attributes.pageID);    pageTitle_array.push(rootIcon.pages[i].extXML.firstChild.childNodes[0].attributes.name);  }  navOffset = 0;    } else {  // Toolkits    myXML = new XML(extXML.firstChild.childNodes[rootIcon.getPageIndex() - pgOffset]);  pageIcon.templateData = myXML.toObject();    // routed pages only  pageID_array = new Array();   pageTitle_array = new Array();  for (i = 0; i < extXML.firstChild.childNodes.length; i++){    pageID_array.push(extXML.firstChild.childNodes[i].attributes.linkID);    pageTitle_array.push(extXML.firstChild.childNodes[i].attributes.name);  }  navOffset = pgOffset - 1;  }rootIcon.setTitleText(templateData.learningObject[0].name);// end of common opening block// handle multiple page data definitions in a project if (rootIcon.projectPageIndex == undefined){     rootIcon.projectPageIndex = 0;}// check if this page has a definition for the current project index and default to 0 if notif (pageIcon.templateData.scenario[rootIcon.projectPageIndex].name == undefined){  projPI = 0;} else {  projPI = rootIcon.projectPageIndex; }  if (rootIcon.projMode == "dev"){  // set up current scenario value based on Xerte   currentscenario = pageIcon.templateData.scenario[projPI].pageID;} else { // toolkits  // set up current scenario value based XOT or pageTemplates  currentscenario = pageIcon.templateData.scenario[projPI].linkID;}if (pageIcon.templateData.scenario[projPI].narration != undefined){  narration = pageIcon.templateData.scenario[projPI].narration;//  rootIcon.broadcast('showAudio');}]]></SCR>		<SCR isFunc="1" id="fnListToClipboard" name="fnListToClipboard"><![CDATA[// outputs a list of page titles and page ids to the clipboardclipBoardText = "";if (reportStyle == "text"){  for (i = 0; i < pageID_array.length; i++){     // output a list of titles and pageIDs    clipBoardText = clipBoardText + pageLabel + " " + (i + 1) + " " + titleLabel + " " + pageTitle_array[i] + " | " + idLabel + " " + pageID_array[i] + chr(13) + chr(10);  }  System.setClipboard(clipBoardText);} else if (reportStyle == "html"){// html versionclipBoardText = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';clipBoardText = clipBoardText + chr(13) + chr(10);clipBoardText = clipBoardText + '<html><head><title>' + reportTitle + '</title></head><body>';clipBoardText = clipBoardText + chr(13) + chr(10);clipBoardText = clipBoardText + '<table border="1" cellpadding="5">' + chr(13) + chr(10);clipBoardText = clipBoardText + '<tr><td bgcolor="yellow">' + pageLabel + '</td><td bgcolor="lightgreen">' + titleLabel + '</td><td bgcolor="lightblue">' + idLabel + '</td></tr>' + chr(13) + chr(10);  for (i = 0; i < pageID_array.length; i++){      clipBoardText = clipBoardText + '<tr><td bgcolor="yellow">' + (i + 1) + '</td><td bgcolor="lightgreen">' + pageTitle_array[i] + '</td><td bgcolor="lightblue">' + pageID_array[i]  + '</td></tr>' + chr(13) + chr(10);  }  clipBoardText = clipBoardText + '</table></body></html>' + chr(13) + chr(10);  System.setClipboard(clipBoardText);} else {  // do nothing}]]></SCR>		<SCR name="Initialisation"><![CDATA[/** To enable multiple pages to share the same set up data an array is created as a* property of rootIcon, which will persist from page to page.* * This script sets up the array, it will only run for the first scenario page or* after a game over situation has occurred*/ initialisationPage = false;// set up persistent valuesif (rootIcon.scenario.scenarioIndexArray.length == undefined) { // first page to load so set up all globals  initialisationPage = true;  rootIcon.scenario = new Array();    if (rootIcon.projMode == "dev"){    rootIcon.scenarioStartPage = pageIcon.templateData.scenario[projPI].pageID;  } else { // toolkits    rootIcon.scenarioStartPage = pageIcon.templateData.scenario[projPI].linkID;  }      rootIcon.scenarioScoreBoardLen = 300;  // index arrays only contain the name value (unique identifier) of the data item// the similarly named Array contains the detail in named format// e.g. propIndexArray[0] = "it01" propArray[0].name = "it01", propArray[0].title = "a sharp sword"  rootIcon.scenario.propArray = new Array();  rootIcon.scenario.propIndexArray = new Array();  rootIcon.scenario.propscenarioArray = new Array();  rootIcon.scenario.scenarioIndexArray = new Array();  rootIcon.scenario.scenarioIndexArray[0]="Inventory";  rootIcon.scenario.scenarioIndexArray[1]="Off Stage";  rootIcon.scenario.scoreArray = new Array();      // set up pageMode to control display of errors  if (templateData.learningObject[0].authorSupport == "true"){    pageMode = "development";  } else {    pageMode = "live";  }     // set up score options  // change this to an array rootIcon.scenario.scores[0].use, min, max, start, progressBar, currentScore  // remember to change scripts that update scores or read scores to use these new values.  if (pageIcon.templateData.scenario[projPI].gameSetup[0].name != undefined){    rootIcon.scenario.scoreArray[0] = new Array();    rootIcon.scenario.scoreArray[0].use =   pageIcon.templateData.scenario[projPI].gameSetup[0].score1Use;    rootIcon.scenario.scoreArray[0].label = pageIcon.templateData.scenario[projPI].gameSetup[0].score1Label;    rootIcon.scenario.scoreArray[0].minScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score1Min;    rootIcon.scenario.scoreArray[0].maxScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score1Max;    rootIcon.scenario.scoreArray[0].startScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score1Start;    rootIcon.scenario.scoreArray[0].progressBar =   pageIcon.templateData.scenario[projPI].gameSetup[0].score1ProgressBar;    rootIcon.scenario.scoreArray[0].barColour =   pageIcon.templateData.scenario[projPI].gameSetup[0].score1BarColour;    rootIcon.scenario.scoreArray[0].win =   pageIcon.templateData.scenario[projPI].gameSetup[0].score1Win;    rootIcon.scenario.scoreArray[0].lose =   pageIcon.templateData.scenario[projPI].gameSetup[0].score1Lose;    rootIcon.scenario.scoreArray[0].endGameState = "";    rootIcon.scenario.scoreArray[0].winMessage = pageIcon.templateData.scenario[projPI].gameSetup[0].score1WinMessage;    rootIcon.scenario.scoreArray[0].loseMessage = pageIcon.templateData.scenario[projPI].gameSetup[0].score1LoseMessage;        rootIcon.scenario.scoreArray[0].score = parseInt(pageIcon.templateData.scenario[projPI].gameSetup[0].score1Start);    rootIcon.scenario.scoreArray[0].scoreMultiplier = rootIcon.scenarioScoreBoardLen / (rootIcon.scenario.scoreArray[0].maxScore - rootIcon.scenario.scoreArray[0].minScore);    rootIcon.scenario.scoreArray[0].winEndID = pageIcon.templateData.scenario[projPI].gameSetup[0].score1WinEndID;    rootIcon.scenario.scoreArray[0].loseEndID = pageIcon.templateData.scenario[projPI].gameSetup[0].score1LoseEndID;        rootIcon.scenario.scoreArray[1] = new Array();    rootIcon.scenario.scoreArray[1].use =   pageIcon.templateData.scenario[projPI].gameSetup[0].score2Use;    rootIcon.scenario.scoreArray[1].label = pageIcon.templateData.scenario[projPI].gameSetup[0].score2Label;    rootIcon.scenario.scoreArray[1].minScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score2Min;    rootIcon.scenario.scoreArray[1].maxScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score2Max;    rootIcon.scenario.scoreArray[1].startScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score2Start;    rootIcon.scenario.scoreArray[1].progressBar =   pageIcon.templateData.scenario[projPI].gameSetup[0].score2ProgressBar;    rootIcon.scenario.scoreArray[1].barColour =   pageIcon.templateData.scenario[projPI].gameSetup[0].score2BarColour;    rootIcon.scenario.scoreArray[1].win =   pageIcon.templateData.scenario[projPI].gameSetup[0].score2Win;    rootIcon.scenario.scoreArray[1].lose =   pageIcon.templateData.scenario[projPI].gameSetup[0].score2Lose;    rootIcon.scenario.scoreArray[1].endGameState = "";    rootIcon.scenario.scoreArray[1].winMessage = pageIcon.templateData.scenario[projPI].gameSetup[0].score2WinMessage;    rootIcon.scenario.scoreArray[1].loseMessage = pageIcon.templateData.scenario[projPI].gameSetup[0].score2LoseMessage;        rootIcon.scenario.scoreArray[1].score = parseInt(pageIcon.templateData.scenario[projPI].gameSetup[0].score2Start);    rootIcon.scenario.scoreArray[1].scoreMultiplier = rootIcon.scenarioScoreBoardLen / (rootIcon.scenario.scoreArray[1].maxScore - rootIcon.scenario.scoreArray[1].minScore);    rootIcon.scenario.scoreArray[1].winEndID = pageIcon.templateData.scenario[projPI].gameSetup[0].score2WinEndID;    rootIcon.scenario.scoreArray[1].loseEndID = pageIcon.templateData.scenario[projPI].gameSetup[0].score2LoseEndID;    rootIcon.scenario.scoreArray[2] = new Array();    rootIcon.scenario.scoreArray[2].use =   pageIcon.templateData.scenario[projPI].gameSetup[0].score3Use;    rootIcon.scenario.scoreArray[2].label = pageIcon.templateData.scenario[projPI].gameSetup[0].score3Label;    rootIcon.scenario.scoreArray[2].minScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score3Min;    rootIcon.scenario.scoreArray[2].maxScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score3Max;    rootIcon.scenario.scoreArray[2].startScore =   pageIcon.templateData.scenario[projPI].gameSetup[0].score3Start;    rootIcon.scenario.scoreArray[2].progressBar =   pageIcon.templateData.scenario[projPI].gameSetup[0].score3ProgressBar;    rootIcon.scenario.scoreArray[2].barColour =   pageIcon.templateData.scenario[projPI].gameSetup[0].score3BarColour;    rootIcon.scenario.scoreArray[2].win =   pageIcon.templateData.scenario[projPI].gameSetup[0].score3Win;    rootIcon.scenario.scoreArray[2].lose =   pageIcon.templateData.scenario[projPI].gameSetup[0].score3Lose;    rootIcon.scenario.scoreArray[2].endGameState = "";    rootIcon.scenario.scoreArray[2].winMessage = pageIcon.templateData.scenario[projPI].gameSetup[0].score3WinMessage;    rootIcon.scenario.scoreArray[2].loseMessage = pageIcon.templateData.scenario[projPI].gameSetup[0].score3LoseMessage;        rootIcon.scenario.scoreArray[2].score = parseInt(pageIcon.templateData.scenario[projPI].gameSetup[0].score3Start);    rootIcon.scenario.scoreArray[2].scoreMultiplier = rootIcon.scenarioScoreBoardLen / (rootIcon.scenario.scoreArray[2].maxScore - rootIcon.scenario.scoreArray[2].minScore);    rootIcon.scenario.scoreArray[2].winEndID = pageIcon.templateData.scenario[projPI].gameSetup[0].score3WinEndID;    rootIcon.scenario.scoreArray[2].loseEndID = pageIcon.templateData.scenario[projPI].gameSetup[0].score3LoseEndID;        if (pageIcon.templateData.scenario[projPI].gameSetup[0].loseEffect != undefined){      rootIcon.scenario.scoreArray.loseEffect = pageIcon.templateData.scenario[projPI].gameSetup[0].loseEffect;    }    if (pageIcon.templateData.scenario[projPI].gameSetup[0].winEffect != undefined){      rootIcon.scenario.scoreArray.winEffect = pageIcon.templateData.scenario[projPI].gameSetup[0].winEffect;    }              }  rootIcon.scenario.scoreArray.gameOver = "false";  }    ]]></SCR>		<SCR name="setUpLanguage"><![CDATA[/**  This script sets up the various text items that will be consistent across all* the scenario pages in the project - again using the rootIcon.scenario array.*/ if ( initialisationPage == true) { // first page to load so set up language strings  rootIcon.scenario.lang = new Array();  rootIcon.scenario.lang[0].imageButtonShow = pageIcon.templateData.scenario[projPI].imageButtonShow;  rootIcon.scenario.lang[0].imageButtonHide = pageIcon.templateData.scenario[projPI].imageButtonHide;  rootIcon.scenario.lang[0].imageButtonWidth = pageIcon.templateData.scenario[projPI].imageButtonWidth;  rootIcon.scenario.lang[0].btnContinueLabel = pageIcon.templateData.scenario[projPI].continueButtonLabel;  rootIcon.scenario.lang[0].continueButtonWidth = pageIcon.templateData.scenario[projPI].continueButtonWidth;  rootIcon.scenario.lang[0].scenarioPropsTitle = pageIcon.templateData.scenario[projPI].scenarioPropsTitle;  rootIcon.scenario.lang[0].scenarioPropsName = pageIcon.templateData.scenario[projPI].scenarioPropsName;    rootIcon.scenario.lang[0].inventoryEmpty = pageIcon.templateData.scenario[projPI].inventoryEmpty;  rootIcon.scenario.lang[0].inventoryTitle = pageIcon.templateData.scenario[projPI].inventoryTitle;  rootIcon.scenario.lang[0].inventoryItemName = pageIcon.templateData.scenario[projPI].inventoryItemName;  rootIcon.scenario.lang[0].actionTitle = pageIcon.templateData.scenario[projPI].actionTitle;  rootIcon.scenario.lang[0].scoresTitle = pageIcon.templateData.scenario[projPI].scoresTitle;  rootIcon.scenario.lang[0].scoresDebugMessage = pageIcon.templateData.scenario[projPI].scoresDebugMessage;  rootIcon.scenario.lang[0].reportTitle = pageIcon.templateData.scenario[projPI].reportTitle;  rootIcon.scenario.lang[0].pageLabel = pageIcon.templateData.scenario[projPI].pageLabel;  rootIcon.scenario.lang[0].titleLabel = pageIcon.templateData.scenario[projPI].titleLabel;  rootIcon.scenario.lang[0].idLabel = pageIcon.templateData.scenario[projPI].idLabel;  rootIcon.scenario.lang[0].notFoundMessage = pageIcon.templateData.scenario[projPI].notFoundMessage;  rootIcon.scenario.lang[0].notSetMessage = pageIcon.templateData.scenario[projPI].notSetMessage;}  ]]></SCR>		<SCR isFunc="1" id="fnPropAction" name="fnPropAction"><![CDATA[/** This script is used as a function* It is called when the page is loaded and each time an action is selected by the user, * so that the page details are be updated with the outcomes of the action. * * It loops through rootIcon.scenario.propArray to build up an array * of all the props that are in the inventory, and * all the props that have a scenario value of the current scenario, * it also builds an array of all their actions which have their * conditions met, and a series of arrays listing the props that match each prop location grouping.* */ // fnPropActionactionArray = new Array();effectArray = new Array();// identify which props are either at this location or are carriedpropsInscenarioArray = new Array(); // onStage i.e. current Location and Visible - used to display list of objects seeninventoryArray = new Array();  // Inventory and Visible - used to display objects in inventory// the following are lookup arrays containing prop names only as quick check on propStates// there is an array for each available propState// presentArray = new Array(); // location == current scenario && prop state == visible// new arrays for prop location groupingsonStageArray = new Array(); // current locationnotOnStageArray = new Array(); // inventory or other location but not current locationcarriedArray = new Array(); // inventory (visible and hidden)notCarriedArray = new Array();  // either current location or other location but not inventoryoffStageArray = new Array(); // not current location or inventory - aka absentArrayinSceneArray = new Array(); // carried or onStage but not other locationvisibleArray = new Array(); // state == visiblehiddenArray = new Array(); // state == hidden/*  absentArray = new Array(); // location != Inventory && location != current scenario hidingArray = new Array(); // prop state == hidden && (location == inventory || location == current scenario) carriedArray = new Array(); // location == inventory notCarriedArray = new Array(); // location != inventory accessibleArray = new Array(); // prop state == visible && (location == inventory || location == current scenario)*/ for (i=0; i < rootIcon.scenario.propArray.length; i++){	// first set up state	if(rootIcon.scenario.propArray[i].state == "visible"){ 		visibleArray.push(i);	} else {		hiddenArray.push(i);	}	// now sort out location based arrays	if (rootIcon.scenario.propArray[i].scenario == currentscenario){		onStageArray.push(i);  		notCarriedArray.push(i);		inSceneArray.push(i);		if(rootIcon.scenario.propArray[i].state == "visible"){			// current scene and visible so add to array that will list what you can see			propsInscenarioArrayIndex = propsInscenarioArray.length;			propsInscenarioArray[propsInscenarioArrayIndex] = new Array();			propsInscenarioArray[propsInscenarioArrayIndex].name = rootIcon.scenario.propArray[i].name;			propsInscenarioArray[propsInscenarioArrayIndex].title = rootIcon.scenario.propArray[i].title;			propsInscenarioArray[propsInscenarioArrayIndex].description = rootIcon.scenario.propArray[i].description;		}    	} else if (rootIcon.scenario.propArray[i].scenario == "Inventory"){		// carried		carriedArray.push(i);		notOnStageArray.push(i);		inSceneArray.push(i);     		if(rootIcon.scenario.propArray[i].state == "visible"){  			// add its details to the inventory array			inventoryArrayIndex = inventoryArray.length;			inventoryArray[inventoryArrayIndex] = new Array();			inventoryArray[inventoryArrayIndex].name = rootIcon.scenario.propArray[i].name;			inventoryArray[inventoryArrayIndex].title = rootIcon.scenario.propArray[i].title;			inventoryArray[inventoryArrayIndex].description = rootIcon.scenario.propArray[i].description; 		} 	} else { // not at current location or in inventory		// not carried		offStageArray.push(i);		notCarriedArray.push(i);    		offStageArray.push(i);	}} // prop array loop// we now have arrays set up// inSceneArray contains both hidden and visible objectsif (inSceneArray.length != undefined){	for (n=0; n < inSceneArray.length; n++){ // loop through array of prop indexes for props that can initiate actions in this scenario		i = inSceneArray[n]; // the index of the prop in rootIcon.scenario.propArray		if (rootIcon.scenario.propArray[i].length != undefined){			for (j=0; j < rootIcon.scenario.propArray[i].length; j++){ // loop through actions				// test action conditions for validity - all conditions must pass for action to take place				allowAction = "true";				currentActionType = rootIcon.scenario.propArray[i][j].actionType; // (action or effect)				for (k=0; k < rootIcon.scenario.propArray[i][j][0].length; k++){ // loop through conditions for this action					if (allowAction == "true"){       // only carry out further condition tests if no condition has failed						// start of all condition tests						// check which prop we using in this condition for conditions that relate to a prop						if (rootIcon.scenario.propArray[i][j][0][k].propName == undefined){ // name of property in condition							thisProp = rootIcon.scenario.propArray[i].name;							thisPropIndex = i;						} else {							thisProp = rootIcon.scenario.propArray[i][j][0][k].propName;							// find array for this prop							thisPropIndex = rootIcon.scenario.propIndexArray.findValue(thisProp);          						} // if else						// if thisPropIndex = -1 then the propName specified could not be found						  						// test for propState						if (rootIcon.scenario.propArray[i][j][0][k].propState != undefined){							// we have a prop related condition so find out which prop it relates to							// confirm prop exists							if (thisPropIndex == -1){								allowAction = "false"; // prop not found							} else {								// now test for propState conditions								switch(rootIcon.scenario.propArray[i][j][0][k].propState){									// prop that is the subject of the condition may not be the same as the prop that has the action									case "visible":										if (visibleArray.findValue(thisPropIndex) == -1){  // prop is not present in presentArray											allowAction = "false";                										}										break;									case "hidden":										if (hiddenArray.findValue(thisPropIndex) == -1){											// prop not in absent list											allowAction = "false";										}             										break;									default: // undefined										// no action required if no propState value specified								} //  end switch case propState 							} // this propIndex						} // propState not undefined							// end of propState tests						 						// test for propLoc						if (rootIcon.scenario.propArray[i][j][0][k].propLoc != undefined){							// we have a prop related condition so find out which prop it relates to							// confirm prop exists							if (thisPropIndex == -1){								allowAction = "false"; // prop not found							} else {								// now test for propState conditions								switch(rootIcon.scenario.propArray[i][j][0][k].propLoc){									// prop that is the subject of the condition may not be the same as the prop that has the action									case "onStage":										if (onStageArray.findValue(thisPropIndex) == -1){  // prop is not present in presentArray											allowAction = "false";                										}										break;									case "carried":										if (carriedArray.findValue(thisPropIndex) == -1){											// prop not in absent list											allowAction = "false";										}             										break;									case "offStage":										if (offStageArray.findValue(thisPropIndex) == -1){											// not carried;											allowAction = "false";										} 										break;            									case "notOnStage":										if (notOnStageArray.findValue(thisPropIndex) == -1){											// not carried;											allowAction = "false";										}										break;									case "notCarried":										if (notCarriedArray.findValue(thisPropIndex) == -1){											// carried;											allowAction = "false";										} 										break;									case "inScene":										if (inSceneArray.findValue(thisPropIndex) == -1){											// carried;											allowAction = "false";										}										break;                                    									default: // undefined										// no action required if no propLoc value specified								} //  end switch case propLoc 							} // this propIndex						} // propLoc not undefined						// end of propLoc tests						// now test the scenario related options						if (rootIcon.scenario.propArray[i][j][0][k].scenarioID != undefined){ // name of scenario in condition							// need to test values for scenarioState							switch(rootIcon.scenario.propArray[i][j][0][k].scenarioState){								// prop that is the subject of the condition may not be the same as the prop that has the action								case "current":									if (rootIcon.scenario.propArray[i][j][0][k].scenarioID != currentscenario){										// test is current but condition scenario value is not current scenario										allowAction = "false";									}									break;								case "notCurrent":									if (rootIcon.scenario.propArray[i][j][0][k].scenarioID == currentscenario){										// test is notCurrent but condition scenario value is the current scenario										allowAction = "false";									}              									break;								default: // undefined									// reject action as improperly formed condition									allowAction = "false";              							} // switch 						} // if scenarioID specified										// now test for score value						if (rootIcon.scenario.propArray[i][j][0][k].scoreNumber != undefined){ // name of scenario in condition      							// need to test values for specified score							switch(rootIcon.scenario.propArray[i][j][0][k].scoreNumber){								case "1":									testScore = rootIcon.scenario.scoreArray[0].score;									break;								case "2":									testScore = rootIcon.scenario.scoreArray[1].score;									break;								case "3":									testScore = rootIcon.scenario.scoreArray[2].score;									break;								case "4":									// inventory									testScore = inventoryArray.length;                									break;			  								default: // undefined									// reject action as improperly formed condition									allowAction = "false"; 							} // switch				 							switch(rootIcon.scenario.propArray[i][j][0][k].scoreComp){								// prop that is the subject of the condition may not be the same as the prop that has the action								case "LT":									if (testScore >= rootIcon.scenario.propArray[i][j][0][k].scoreVal){										// test is current but condition scenario value is not current scenario										allowAction = "false";									}									break;								case "GT":									if (testScore <= rootIcon.scenario.propArray[i][j][0][k].scoreVal){										// test is notCurrent but condition scenario value is the current scenario										allowAction = "false";									}              									break;								case "EQ":									if (testScore != rootIcon.scenario.propArray[i][j][0][k].scoreVal){										// test is notCurrent but condition scenario value is the current scenario										allowAction = "false";									}              									break;            								default: // undefined									// reject action as improperly formed condition									allowAction = "false"; 							} // switch 												} // if scoreNumber specified               						// now test the chanceAct option against a random number						if (rootIcon.scenario.propArray[i][j][0][k].chanceAct != undefined){ // 							// need to test values for scenarioState							myRand = Math.floor(Math.random() * 10); // returns 0 through 9							myChanceAct = parseInt(rootIcon.scenario.propArray[i][j][0][k].chanceAct);							if (myRand >= myChanceAct){								allowAction = "false";							}						}										} // allowAction test				}  // end condition loop							// still looping through actions				if (allowAction == "true") {					if (rootIcon.scenario.propArray[i][j][1].length == undefined) {						// there are no outcomes so only use it if it is an effect						if (currentActionType == "effect") {							// add effect to effect array							myArrayIndex = effectArray.length;							effectArray[myArrayIndex] = new Array();							effectArray[myArrayIndex].title = rootIcon.scenario.propArray[i][j].title;							effectArray[myArrayIndex].actionText = rootIcon.scenario.propArray[i][j].actionText;						}					} else {						// we have at least one outcome so create an entry for the action or effect						if (currentActionType == "action") {							// create a new actionArray entry							myArrayIndex = actionArray.length;							actionArray[myArrayIndex] = new Array();							actionArray[myArrayIndex].title = rootIcon.scenario.propArray[i][j].title;							actionArray[myArrayIndex].actionText = rootIcon.scenario.propArray[i][j].actionText;											} else {							// create a new effectArray entry							myArrayIndex = effectArray.length;							effectArray[myArrayIndex] = new Array();							effectArray[myArrayIndex].title = rootIcon.scenario.propArray[i][j].title;							effectArray[myArrayIndex].actionText = rootIcon.scenario.propArray[i][j].actionText;											}						// now loop through the outcomes adding only those where all outcome conditions are valid 						for (l = 0; l < rootIcon.scenario.propArray[i][j][1].length; l++) {							// does the outcome have any outcome conditions?							if (rootIcon.scenario.propArray[i][j][1][l].length == undefined) {								// no conditions so we can simply add the outcome to the action or effect								if (currentActionType == "action") {									outcomeIndex = actionArray[myArrayIndex].length;									actionArray[myArrayIndex][outcomeIndex] = new Array();									actionArray[myArrayIndex][outcomeIndex].outcomeText = rootIcon.scenario.propArray[i][j][1][l].outcomeText;        									actionArray[myArrayIndex][outcomeIndex].score1Inc = rootIcon.scenario.propArray[i][j][1][l].score1Inc;									actionArray[myArrayIndex][outcomeIndex].score2Inc = rootIcon.scenario.propArray[i][j][1][l].score2Inc;									actionArray[myArrayIndex][outcomeIndex].score3Inc = rootIcon.scenario.propArray[i][j][1][l].score3Inc;									actionArray[myArrayIndex][outcomeIndex].soundEffect = rootIcon.scenario.propArray[i][j][1][l].soundEffect;								  									// if propName has not been set in the outcome it must be set here to the current prop so that									// the author can just select a change of state without having to always set the prop									if (rootIcon.scenario.propArray[i][j][1][l].propName == undefined){									  actionArray[myArrayIndex][outcomeIndex].propName = rootIcon.scenario.propArray[i].name;									} else {									  actionArray[myArrayIndex][outcomeIndex].propName = rootIcon.scenario.propArray[i][j][1][l].propName;          									}									actionArray[myArrayIndex][outcomeIndex].propState = rootIcon.scenario.propArray[i][j][1][l].propState;									actionArray[myArrayIndex][outcomeIndex].propAction = rootIcon.scenario.propArray[i][j][1][l].propAction;									actionArray[myArrayIndex][outcomeIndex].specifiedLoc = rootIcon.scenario.propArray[i][j][1][l].specifiedLoc;									actionArray[myArrayIndex][outcomeIndex].destination = rootIcon.scenario.propArray[i][j][1][l].destination;								} else {									outcomeIndex = effectArray[myArrayIndex].length;									effectArray[myArrayIndex][outcomeIndex] = new Array();									effectArray[myArrayIndex][outcomeIndex].outcomeText = rootIcon.scenario.propArray[i][j][1][l].outcomeText;        									effectArray[myArrayIndex][outcomeIndex].score1Inc = rootIcon.scenario.propArray[i][j][1][l].score1Inc;									effectArray[myArrayIndex][outcomeIndex].score2Inc = rootIcon.scenario.propArray[i][j][1][l].score2Inc;									effectArray[myArrayIndex][outcomeIndex].score3Inc = rootIcon.scenario.propArray[i][j][1][l].score3Inc;									effectArray[myArrayIndex][outcomeIndex].soundEffect = rootIcon.scenario.propArray[i][j][1][l].soundEffect;								  									// if propName has not been set in the outcome it must be set here to the current prop so that									// the author can just select a change of state without having to always set the prop									if (rootIcon.scenario.propArray[i][j][1][l].propName == undefined){									  effectArray[myArrayIndex][outcomeIndex].propName = rootIcon.scenario.propArray[i].name;									} else {									  effectArray[myArrayIndex][outcomeIndex].propName = rootIcon.scenario.propArray[i][j][1][l].propName;          									}									effectArray[myArrayIndex][outcomeIndex].propState = rootIcon.scenario.propArray[i][j][1][l].propState;									effectArray[myArrayIndex][outcomeIndex].propAction = rootIcon.scenario.propArray[i][j][1][l].propAction;									effectArray[myArrayIndex][outcomeIndex].specifiedLoc = rootIcon.scenario.propArray[i][j][1][l].specifiedLoc;									effectArray[myArrayIndex][outcomeIndex].destination = rootIcon.scenario.propArray[i][j][1][l].destination;								}							} else {									// we have outcome conditions so we must check all outcome conditions								// to see if all conditions are met before the action can be added to 								// the action array								allowOutcome = "true";								for (m = 0; m < rootIcon.scenario.propArray[i][j][1][l].length; m++) {									// looping through the outcomeConditions and test them														// check which prop we using in this condition for conditions that relate to a prop																if (rootIcon.scenario.propArray[i][j][1][l][m].propName == undefined){										thisProp = rootIcon.scenario.propArray[i].name;										thisPropIndex = i;									} else {										thisProp = rootIcon.scenario.propArray[i][j][1][l][m].propName;										thisPropIndex = rootIcon.scenario.propIndexArray.findValue(thisProp); 									}									// test for propState									if (rootIcon.scenario.propArray[i][j][1][l][m].propState != undefined){										// we have a prop related condition so find out which prop it relates to										// confirm prop exists										if (thisPropIndex == -1){											allowOutcome = "false"; // prop not found										} else {											// now test for propState conditions											switch(rootIcon.scenario.propArray[i][j][1][l][m].propState){											// prop that is the subject of the condition may not be the same as the prop that has the action												case "visible":													if (visibleArray.findValue(thisPropIndex) == -1){  // prop is not present in presentArray													  allowOutcome = "false";                													}													break;												case "hidden":													if (hiddenArray.findValue(thisPropIndex) == -1){													  // prop not in absent list													  allowOutcome = "false";													}             													break;												default: // undefined												// no action required if no propState value specified											} //  end switch case propState 										} // this propIndex									} // propState not undefined									// end of propState tests																			// test for propLoc									if (rootIcon.scenario.propArray[i][j][1][l][m].propLoc != undefined){										// we have a prop related condition so find out which prop it relates to										// confirm prop exists										if (thisPropIndex == -1){											allowOutcome = "false"; // prop not found										} else {											// now test for propLoc conditions											switch(rootIcon.scenario.propArray[i][j][1][l][m].propLoc){												// prop that is the subject of the condition may not be the same as the prop that has the action												case "onStage":													if (onStageArray.findValue(thisPropIndex) == -1){  // prop is not present in presentArray														allowOutcome = "false";                													}													break;												case "carried":													if (carriedArray.findValue(thisPropIndex) == -1){														// prop not in absent list														allowOutcome = "false";													}             													break;												case "offStage":													if (offStageArray.findValue(thisPropIndex) == -1){													// not carried;													allowOutcome = "false";													} 													break;            												case "notOnStage":													if (notOnStageArray.findValue(thisPropIndex) == -1){														// not carried;														allowOutcome = "false";													}													break;												case "notCarried":													if (notCarriedArray.findValue(thisPropIndex) == -1){														// carried;														allowOutcome = "false";													} 													break;												case "inScene":													if (inSceneArray.findValue(thisPropIndex) == -1){														// carried;														allowOutcome = "false";													}													break;                                    												default: // undefined													// no action required if no propState value specified											} //  end switch case propState 										} // this propIndex									} // propLoc not undefined									  // end of propLoc tests															// now test the scenario related options									if (rootIcon.scenario.propArray[i][j][1][l][m].scenarioID != undefined){ // name of scenario in condition										// need to test values for scenarioState										switch(rootIcon.scenario.propArray[i][j][1][l][m].scenarioState){											// prop that is the subject of the condition may not be the same as the prop that has the action											case "current":												if (rootIcon.scenario.propArray[i][j][1][l][m].scenarioID != currentscenario){													// test is current but condition scenario value is not current scenario													allowOutcome = "false";												}												break;											case "notCurrent":												if (rootIcon.scenario.propArray[i][j][1][l][m].scenarioID == currentscenario){													// test is notCurrent but condition scenario value is the current scenario													allowOutcome = "false";												}              												break;											default: // undefined												// reject action as improperly formed condition												allowOutcome = "false";              										} // switch 									} // if scenarioID specified																		// now test for score value									if (rootIcon.scenario.propArray[i][j][1][l][m].scoreNumber != undefined){ // name of scenario in condition      										// need to test values for specified score										switch(rootIcon.scenario.propArray[i][j][1][l][m].scoreNumber){											case "1":												testScore = rootIcon.scenario.scoreArray[0].score;												break;											case "2":												testScore = rootIcon.scenario.scoreArray[1].score;												break;											case "3":												testScore = rootIcon.scenario.scoreArray[2].score;												break;											case "4":												// inventory												testScore = inventoryArray.length;                												break;			  											default: // undefined												// reject action as improperly formed condition												allowOutcome = "false"; 										} // switch										switch(rootIcon.scenario.propArray[i][j][1][l][m].scoreComp){											// prop that is the subject of the condition may not be the same as the prop that has the action											case "LT":												if (testScore >= rootIcon.scenario.propArray[i][j][1][l][m].scoreVal){													// test is current but condition scenario value is not current scenario													allowOutcome = "false";												}												break;											case "GT":												if (testScore <= rootIcon.scenario.propArray[i][j][1][l][m].scoreVal){													// test is notCurrent but condition scenario value is the current scenario													allowOutcome = "false";												}              												break;											case "EQ":												if (testScore != rootIcon.scenario.propArray[i][j][1][l][m].scoreVal){													// test is notCurrent but condition scenario value is the current scenario													allowOutcome = "false";												}              												break;            											default: // undefined												// reject action as improperly formed condition												allowOutcome = "false"; 										} // switch 																			} // if scoreNumber specified 																		// now test the chanceAct option against a random number									if (rootIcon.scenario.propArray[i][j][1][l][m].chanceAct != undefined){ // 										// need to test values for scenarioState										myRand = Math.floor(Math.random() * 10); // returns 0 through 9										myChanceAct = parseInt(rootIcon.scenario.propArray[i][j][1][l][m].chanceAct);										if (myRand >= myChanceAct){											allowOutcome = "false";										}									}														} // outcome condition loop													if (allowOutcome == "true") {									// add outcome to effect or action									if (currentActionType == "action") {										outcomeIndex = actionArray[myArrayIndex].length;										actionArray[myArrayIndex][outcomeIndex] = new Array();										actionArray[myArrayIndex][outcomeIndex].name = rootIcon.scenario.propArray[i][j][1][l].name;										actionArray[myArrayIndex][outcomeIndex].outcomeText = rootIcon.scenario.propArray[i][j][1][l].outcomeText;        										actionArray[myArrayIndex][outcomeIndex].score1Inc = rootIcon.scenario.propArray[i][j][1][l].score1Inc;										actionArray[myArrayIndex][outcomeIndex].score2Inc = rootIcon.scenario.propArray[i][j][1][l].score2Inc;										actionArray[myArrayIndex][outcomeIndex].score3Inc = rootIcon.scenario.propArray[i][j][1][l].score3Inc;										actionArray[myArrayIndex][outcomeIndex].soundEffect = rootIcon.scenario.propArray[i][j][1][l].soundEffect;																		  										// if propName has not been set in the outcome it must be set here to the current prop so that										// the author can just select a change of state without having to always set the prop										if (rootIcon.scenario.propArray[i][j][1][l].propName == undefined){										  actionArray[myArrayIndex][outcomeIndex].propName = rootIcon.scenario.propArray[i].name;										} else {										  actionArray[myArrayIndex][outcomeIndex].propName = rootIcon.scenario.propArray[i][j][1][l].propName;          										}										actionArray[myArrayIndex][outcomeIndex].propState = rootIcon.scenario.propArray[i][j][1][l].propState;										actionArray[myArrayIndex][outcomeIndex].propAction = rootIcon.scenario.propArray[i][j][1][l].propAction;										actionArray[myArrayIndex][outcomeIndex].specifiedLoc = rootIcon.scenario.propArray[i][j][1][l].specifiedLoc;										actionArray[myArrayIndex][outcomeIndex].destination = rootIcon.scenario.propArray[i][j][1][l].destination;									} else {										outcomeIndex = effectArray[myArrayIndex].length;										effectArray[myArrayIndex][outcomeIndex] = new Array();										effectArray[myArrayIndex][outcomeIndex].outcomeText = rootIcon.scenario.propArray[i][j][1][l].outcomeText;        										effectArray[myArrayIndex][outcomeIndex].score1Inc = rootIcon.scenario.propArray[i][j][1][l].score1Inc;										effectArray[myArrayIndex][outcomeIndex].score2Inc = rootIcon.scenario.propArray[i][j][1][l].score2Inc;										effectArray[myArrayIndex][outcomeIndex].score3Inc = rootIcon.scenario.propArray[i][j][1][l].score3Inc;										effectArray[myArrayIndex][outcomeIndex].soundEffect = rootIcon.scenario.propArray[i][j][1][l].soundEffect;									  										// if propName has not been set in the outcome it must be set here to the current prop so that										// the author can just select a change of state without having to always set the prop										if (rootIcon.scenario.propArray[i][j][1][l].propName == undefined){										  effectArray[myArrayIndex][outcomeIndex].propName = rootIcon.scenario.propArray[i].name;										} else {										  effectArray[myArrayIndex][outcomeIndex].propName = rootIcon.scenario.propArray[i][j][1][l].propName;          										}										effectArray[myArrayIndex][outcomeIndex].propState = rootIcon.scenario.propArray[i][j][1][l].propState;										effectArray[myArrayIndex][outcomeIndex].propAction = rootIcon.scenario.propArray[i][j][1][l].propAction;										effectArray[myArrayIndex][outcomeIndex].specifiedLoc = rootIcon.scenario.propArray[i][j][1][l].specifiedLoc;										effectArray[myArrayIndex][outcomeIndex].destination = rootIcon.scenario.propArray[i][j][1][l].destination;									}																	} // allowOutcomes is true																					} // if we have outcome conditions							}	// outcomes loop						// need to remove the action if it has no outcomes						if (currentActionType == "action") {							if (actionArray[myArrayIndex].length == 0) {								// there are no outcomes								actionArray.pop();							}						}					} // are there outcomes test									} // if allowableAction == true						} // loop through actions / effects						}	// propArray[i].length defined							} // loop through props} // inSceneArray.length is defined]]></SCR>		<SCR isFunc="1" id="fnscenarioAction" name="fnscenarioAction"><![CDATA[/** This script is used as a function* It loops through the scenarioActions defined in templateData for this page * to build an array of all the actions for this scenario which have their * conditions met.* * It is called when the page is loaded and each time an action is selected by the user, * so that the page details can be updated after an action has taken place.*/ // fnScenarioActionif (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction.length != undefined) {	for (i=0; i < pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction.length; i++){ 		allowAction = "true";		currentActionType = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionType;		if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition.length != undefined) {		//	pageActionArray[i][0] = new Array(); // for conditions			for (j=0; j < pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition.length; j++){				if (allowAction == "true"){					// start of all condition checks					// test prop related conditions, set allowAction to false if a condition fails					if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].propName != undefined){ // check a prop condition exists						// a prop related condition has been defined						thisProp = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].propName;						// find array for this prop						thisPropIndex = rootIcon.scenario.propIndexArray.findValue(thisProp);          						if (thisPropIndex != -1){ // prop can be found							// a prop related condition has been specified							// test the propState							switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].propState){								case "visible":									if (visibleArray.findValue(thisPropIndex) == -1){										// prop is not present in presentArray										allowAction = "false";									}									break;								case "hidden":									if (hiddenArray.findValue(thisPropIndex) == -1){										// not hiding;										allowAction = "false";									}									break;            								default: // undefined									// no action required if no propState value specified							} //  end switch case propState 				  							// switch case propLoc  							switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].propLoc){								case "onStage":									if (onStageArray.findValue(thisPropIndex) == -1){  // prop is not present in presentArray										allowAction = "false";									}									break;								case "carried":									if (carriedArray.findValue(thisPropIndex) == -1){										// not carried;										allowAction = "false";									}									break;								case "offStage":									if (offStageArray.findValue(thisPropIndex) == -1){										allowAction = "false";									}             									break;								case "notOnStage":									if (notOnStageArray.findValue(thisPropIndex) == -1){										// not hiding;										allowAction = "false";									}									break;            								case "notCarried":									if (notCarriedArray.findValue(thisPropIndex) == -1){										// carried;										allowAction = "false";									}									break;								case "inScene":									if (inSceneArray.findValue(thisPropIndex) == -1){										// not accessible;										allowAction = "false";									}									break;                                    									default: // undefined										// no action required if no propState value specified							} //  end switch case propLoc 						} else {							// this prop does not exist in propIndexArray							allowAction="false";						} // end if propIndex test					} // if propname undefined - end of prop condition tests										// now test the scenario related options					if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scenarioID != undefined){ // name of scenario in condition						// need to test values for scenarioState						switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scenarioState){							// prop that is the subject of the condition may not be the same as the prop that has the action							case "current":								if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scenarioID != currentscenario){									// test is current but condition scenario value is not current scenario									allowAction = "false";								}								break;							case "notCurrent":								if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scenarioID == currentscenario){									// test is notCurrent but condition scenario value is the current scenario									allowAction = "false";								}              								break;							default: // undefined								// reject action as improperly formed condition								allowAction = "false";              						} // switch 					} // if scenarioID specified					// now test for score value					if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scoreNumber != undefined){ // name of scenario in condition      						// need to test values for specified score						switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scoreNumber){							case "1":								testScore = rootIcon.scenario.scoreArray[0].score;								break;							case "2":								testScore = rootIcon.scenario.scoreArray[1].score;                								break;							case "3":								testScore = rootIcon.scenario.scoreArray[2].score;                								break;							case "4":								// inventory								testScore = inventoryArray.length;                								break;											default: // undefined								// reject action as improperly formed condition								allowAction = "false"; 						}	 						switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scoreComp){							// prop that is the subject of the condition may not be the same as the prop that has the action							case "LT":								if (testScore >= pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scoreVal){									// test is current but condition scenario value is not current scenario									allowAction = "false";								}								break;							case "GT":								if (testScore <= pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scoreVal){									// test is notCurrent but condition scenario value is the current scenario									allowAction = "false";								}              								break;							case "EQ":								if (testScore != pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].scoreVal){									// test is notCurrent but condition scenario value is the current scenario									allowAction = "false";								}              								break;            							default: // undefined								// reject action as improperly formed condition								allowAction = "false"; 						} // case 					} // if scoreNumber specified    					// now test the chanceAct option against a random number					if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].chanceAct != undefined){ // name of scenario in condition						// need to test values for scenarioState						myRand = Math.floor(Math.random() * 10); // returns 0 through 9						myChanceAct = parseInt(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionCondition[j].chanceAct);						if (myRand >= myChanceAct){							allowAction = false;						}					}				    // end of all condition checks				}  // if allowed = true			} // end of condition loop j counter		} // end of if action conditions.length		if (allowAction == "true") {					if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome.length == undefined){				// there are no outcomes so only use it if it is an effect				if (currentActionType == "effect") {					// add effect to effect array					myArrayIndex = effectArray.length;					effectArray[myArrayIndex] = new Array();					effectArray[myArrayIndex].title = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].title;					effectArray[myArrayIndex].actionText = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionText;				}			} else {				// we have at least one outcome so create an entry for the action or effect				if (currentActionType == "action") {					// create a new actionArray entry					myArrayIndex = actionArray.length;					actionArray[myArrayIndex] = new Array();					actionArray[myArrayIndex].title = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].title;					actionArray[myArrayIndex].actionText = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionText;								} else {					// create a new effectArray entry					myArrayIndex = effectArray.length;					effectArray[myArrayIndex] = new Array();					effectArray[myArrayIndex].title = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].title;					effectArray[myArrayIndex].actionText = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionText;									}				// now loop through the outcomes adding only those where all outcome conditions are valid 				for (l = 0; l < pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome.length; l++) {  					// does the outcome have any outcome conditions?					if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].length == undefined) {						// no conditions so we can simply add the outcome to the action or effect						if (currentActionType == "action") {							outcomeIndex = actionArray[myArrayIndex].length;							actionArray[myArrayIndex][outcomeIndex] = new Array();							actionArray[myArrayIndex][outcomeIndex].name = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].name;														actionArray[myArrayIndex][outcomeIndex].outcomeText = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeText;        							actionArray[myArrayIndex][outcomeIndex].score1Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score1Inc;							actionArray[myArrayIndex][outcomeIndex].score2Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score2Inc;							actionArray[myArrayIndex][outcomeIndex].score3Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score3Inc;							actionArray[myArrayIndex][outcomeIndex].soundEffect = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].soundEffect;						  	actionArray[myArrayIndex][outcomeIndex].propName = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propName;          							actionArray[myArrayIndex][outcomeIndex].propState = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propState;							actionArray[myArrayIndex][outcomeIndex].propAction = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propAction;							actionArray[myArrayIndex][outcomeIndex].specifiedLoc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].specifiedLoc;							actionArray[myArrayIndex][outcomeIndex].destination = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].destination;						} else {							outcomeIndex = effectArray[myArrayIndex].length;							effectArray[myArrayIndex][outcomeIndex] = new Array();							effectArray[myArrayIndex][outcomeIndex].name = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].name;  														effectArray[myArrayIndex][outcomeIndex].outcomeText = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeText;        							effectArray[myArrayIndex][outcomeIndex].score1Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score1Inc;							effectArray[myArrayIndex][outcomeIndex].score2Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score2Inc;							effectArray[myArrayIndex][outcomeIndex].score3Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score3Inc;							effectArray[myArrayIndex][outcomeIndex].soundEffect = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].soundEffect;							effectArray[myArrayIndex][outcomeIndex].propName = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propName;          							effectArray[myArrayIndex][outcomeIndex].propState = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propState;							effectArray[myArrayIndex][outcomeIndex].propAction = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propAction;							effectArray[myArrayIndex][outcomeIndex].specifiedLoc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].specifiedLoc;							effectArray[myArrayIndex][outcomeIndex].destination = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].destination;						}					} else {							// we have outcome conditions so we must check all outcome conditions						// to see if all conditions are met before the action can be added to 						// the action array						allowOutcome = "true";						for (m = 0; m < pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].length; m++) {												// looping through the outcomeConditions and test them											thisProp = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].propName;								thisPropIndex = rootIcon.scenario.propIndexArray.findValue(thisProp); 							// test for propState							if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].propState != undefined){								// we have a prop related condition so find out which prop it relates to								// confirm prop exists								if (thisPropIndex == -1){									allowOutcome = "false"; // prop not found								} else {									// now test for propState conditions									switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].propState){									// prop that is the subject of the condition may not be the same as the prop that has the action										case "visible":											if (visibleArray.findValue(thisPropIndex) == -1){  // prop is not present in presentArray											  allowOutcome = "false";                											}											break;										case "hidden":											if (hiddenArray.findValue(thisPropIndex) == -1){											  // prop not in absent list											  allowOutcome = "false";											}             											break;										default: // undefined										// no action required if no propState value specified									} //  end switch case propState 								} // this propIndex							} // propState not undefined							// end of propState tests															// test for propLoc							if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].propLoc != undefined){								// we have a prop related condition so find out which prop it relates to								// confirm prop exists								if (thisPropIndex == -1){									allowOutcome = "false"; // prop not found								} else {									// now test for propLoc conditions									switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].propLoc){										// prop that is the subject of the condition may not be the same as the prop that has the action										case "onStage":											if (onStageArray.findValue(thisPropIndex) == -1){  // prop is not present in presentArray												allowOutcome = "false";                											}											break;										case "carried":											if (carriedArray.findValue(thisPropIndex) == -1){												// prop not in absent list												allowOutcome = "false";											}             											break;										case "offStage":											if (offStageArray.findValue(thisPropIndex) == -1){											// not carried;											allowOutcome = "false";											} 											break;            										case "notOnStage":											if (notOnStageArray.findValue(thisPropIndex) == -1){												// not carried;												allowOutcome = "false";											}											break;										case "notCarried":											if (notCarriedArray.findValue(thisPropIndex) == -1){												// carried;												allowOutcome = "false";											} 											break;										case "inScene":											if (inSceneArray.findValue(thisPropIndex) == -1){												// carried;												allowOutcome = "false";											}											break;                                    										default: // undefined											// no action required if no propState value specified									} //  end switch case propState 								} // this propIndex							} // propLoc not undefined									  // end of propLoc tests													// now test the scenario related options							if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scenarioID != undefined){ // name of scenario in condition								// need to test values for scenarioState								switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scenarioState){									// prop that is the subject of the condition may not be the same as the prop that has the action									case "current":										if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scenarioID != currentscenario){											// test is current but condition scenario value is not current scenario											allowOutcome = "false";										}										break;									case "notCurrent":										if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scenarioID == currentscenario){											// test is notCurrent but condition scenario value is the current scenario											allowOutcome = "false";										}              										break;									default: // undefined										// reject action as improperly formed condition										allowOutcome = "false";              								} // switch 							} // if scenarioID specified																					// now test for score value							if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scoreNumber != undefined){ // name of scenario in condition      								// need to test values for specified score								switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scoreNumber){									case "1":										testScore = rootIcon.scenario.scoreArray[0].score;										break;									case "2":										testScore = rootIcon.scenario.scoreArray[1].score;										break;									case "3":										testScore = rootIcon.scenario.scoreArray[2].score;										break;									case "4":										// inventory										testScore = inventoryArray.length;                										break;			  									default: // undefined										// reject action as improperly formed condition										allowOutcome = "false"; 								} // switch															switch(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scoreComp){									// prop that is the subject of the condition may not be the same as the prop that has the action									case "LT":										if (testScore >= pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scoreVal){											// test is current but condition scenario value is not current scenario											allowOutcome = "false";										}										break;									case "GT":										if (testScore <= pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scoreVal){											// test is notCurrent but condition scenario value is the current scenario											allowOutcome = "false";										}              										break;									case "EQ":										if (testScore != pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].scoreVal){											// test is notCurrent but condition scenario value is the current scenario											allowOutcome = "false";										}              										break;            									default: // undefined										// reject action as improperly formed condition										allowOutcome = "false"; 								} // switch 															} // if scoreNumber specified 							// now test the chanceAct option against a random number							if (pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].chanceAct != undefined){ // 								// need to test values for scenarioState								myRand = Math.floor(Math.random() * 10); // returns 0 through 9								myChanceAct = parseInt(pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeCondition[m].chanceAct);								if (myRand >= myChanceAct){									allowOutcome = "false";								}							}												} // outcome condition loop													if (allowOutcome == "true") {							// add outcome to effect or action							if (currentActionType == "action") {								outcomeIndex = actionArray[myArrayIndex].length;								actionArray[myArrayIndex][outcomeIndex] = new Array();								actionArray[myArrayIndex][outcomeIndex].name = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].name;																actionArray[myArrayIndex][outcomeIndex].outcomeText = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeText;        								actionArray[myArrayIndex][outcomeIndex].score1Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score1Inc;								actionArray[myArrayIndex][outcomeIndex].score2Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score2Inc;								actionArray[myArrayIndex][outcomeIndex].score3Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score3Inc;								actionArray[myArrayIndex][outcomeIndex].soundEffect = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].soundEffect;								actionArray[myArrayIndex][outcomeIndex].propName = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propName;          								actionArray[myArrayIndex][outcomeIndex].propState = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propState;								actionArray[myArrayIndex][outcomeIndex].propAction = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propAction;								actionArray[myArrayIndex][outcomeIndex].specifiedLoc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].specifiedLoc;								actionArray[myArrayIndex][outcomeIndex].destination = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].destination;							} else {								outcomeIndex = effectArray[myArrayIndex].length;								effectArray[myArrayIndex][outcomeIndex] = new Array();								effectArray[myArrayIndex][outcomeIndex].name = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].name;        								effectArray[myArrayIndex][outcomeIndex].outcomeText = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].outcomeText;        								effectArray[myArrayIndex][outcomeIndex].score1Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score1Inc;								effectArray[myArrayIndex][outcomeIndex].score2Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score2Inc;								effectArray[myArrayIndex][outcomeIndex].score3Inc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].score3Inc;								effectArray[myArrayIndex][outcomeIndex].soundEffect = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].soundEffect;								effectArray[myArrayIndex][outcomeIndex].propName = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propName;          								effectArray[myArrayIndex][outcomeIndex].propState = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propState;								effectArray[myArrayIndex][outcomeIndex].propAction = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].propAction;								effectArray[myArrayIndex][outcomeIndex].specifiedLoc = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].specifiedLoc;								effectArray[myArrayIndex][outcomeIndex].destination = pageIcon.templateData.scenario[projPI].scenarioActions[0].userAction[i].actionOutcome[l].destination;							}													} // allowOutcomes is true																	} // if we have outcome conditions											}	// outcomes loop								// need to remove the action if it has no outcomes				if (currentActionType == "action") {					if (actionArray[myArrayIndex].length == 0) {						// there are no outcomes						actionArray.pop();					}				}			} // are there outcomes test		} // if allowableAction == true			} // loop through actions / effects				} // if there are user actions	]]></SCR>		<SCR isFunc="1" id="fnUpdateScore" name="fnUpdateScore"><![CDATA[/**  updates scores and checks for score in range*  receives *  scoreIndex - the array index of the score to change (score 1 = 0, score2 = 1, score 3 = 2)*  scoreInc - the amount to change the score by* * It also refers to rootIcon.scenario.scoreArray to check on Win and Lose conditions so that * scores that exceed their game end conditions trigger the end of the game*/// change scorerootIcon.scenario.scoreArray[scoreIndex].score = parseInt(rootIcon.scenario.scoreArray[scoreIndex].score) + parseInt(scoreInc);  // test score ranges and take appropriate actionif (parseInt(rootIcon.scenario.scoreArray[scoreIndex].score) < parseInt(rootIcon.scenario.scoreArray[scoreIndex].minScore)){  // score below of lowest setting  if (rootIcon.scenario.scoreArray[scoreIndex].lose == "min"){     // this score loses the game    rootIcon.scenario.scoreArray[scoreIndex].endGameState = "L";    rootIcon.scenario.scoreArray.gameOver = "true";    rootIcon.scenario.scoreArray[scoreIndex].score = parseInt(rootIcon.scenario.scoreArray[scoreIndex].minScore);    if (rootIcon.scenario.scoreArray.loseEffect != undefined){      narration = rootIcon.scenario.scoreArray.loseEffect;       rootIcon.broadcast('showAudio');    }    rootIcon.broadcast('onGameEnd');      } else if (rootIcon.scenario.scoreArray[scoreIndex].win == "min") {    // this score wins the game    rootIcon.scenario.scoreArray[scoreIndex].endGameState = "W";    rootIcon.scenario.scoreArray.gameOver = "true";        rootIcon.scenario.scoreArray[scoreIndex].score = parseInt(rootIcon.scenario.scoreArray[scoreIndex].maxScore);    if (rootIcon.scenario.scoreArray.winEffect != undefined){      narration = rootIcon.scenario.scoreArray.winEffect;      rootIcon.broadcast('showAudio');             }    rootIcon.broadcast('onGameEnd');    } else {    rootIcon.scenario.scoreArray[scoreIndex].score = parseInt(rootIcon.scenario.scoreArray[scoreIndex].minScore);  } }if (parseInt(rootIcon.scenario.scoreArray[scoreIndex].score) > parseInt(rootIcon.scenario.scoreArray[scoreIndex].maxScore)){  // score above highest setting  if (rootIcon.scenario.scoreArray[scoreIndex].lose == "max"){     // this score loses the game    rootIcon.scenario.scoreArray[scoreIndex].endGameState = "L";    rootIcon.scenario.scoreArray.gameOver = "true";        rootIcon.scenario.scoreArray[scoreIndex].score = parseInt(rootIcon.scenario.scoreArray[scoreIndex].minScore);    if (rootIcon.scenario.scoreArray.loseEffect != undefined){      narration = rootIcon.scenario.scoreArray.loseEffect;       rootIcon.broadcast('showAudio');    }    rootIcon.broadcast('onGameEnd');      } else if (rootIcon.scenario.scoreArray[scoreIndex].win == "max") {    // this score wins the game    rootIcon.scenario.scoreArray[scoreIndex].endGameState = "W";    rootIcon.scenario.scoreArray.gameOver = "true";        rootIcon.scenario.scoreArray[scoreIndex].score = parseInt(rootIcon.scenario.scoreArray[scoreIndex].maxScore);    if (rootIcon.scenario.scoreArray.winEffect != undefined){      narration = rootIcon.scenario.scoreArray.winEffect;      rootIcon.broadcast('showAudio');             }    rootIcon.broadcast('onGameEnd');    } else {    rootIcon.scenario.scoreArray[scoreIndex].score = parseInt(rootIcon.scenario.scoreArray[scoreIndex].maxScore);  } }]]></SCR>		<SCR isFunc="1" id="fnScoreDisplay" name="fnScoreDisplay"><![CDATA[/* ******************************* function called to set up the score display once the scores have been adjusted* as a result of page loading, effects taking place, or actions taking place.*/ // scoresscoreString = "";yVal = 0;scoreText.clear();for (i=0; i<3; i++){  if (rootIcon.scenario.scoreArray[i].use == "1")){    // draw progress bar    if(rootIcon.scenario.scoreArray[i].progressBar == "1"){             // draw the score board      var_scoreBoardLen = rootIcon.scenarioScoreBoardLen;      var_scoreLen = rootIcon.scenario.scoreArray[i].score * rootIcon.scenario.scoreArray[i].scoreMultiplier;      scoreText.beginFill(0xCCCCCC,100);      scoreText.lineStyle(1,0x000000, 100);      scoreText.drawRect(gutterVal,yVal,(var_scoreBoardLen)+2,10,10);      // draw the score graph      // set base width for score panel      scoreText.beginFill(rootIcon.scenario.scoreArray[i].barColour,100);      scoreText.lineStyle(1,rootIcon.scenario.scoreArray[i].barColour, 100);      scoreText.drawRect(gutterVal +2,yVal + 2,var_scoreLen,6,10);                }    yVal = yVal + 28;    scoreString = scoreString + rootIcon.scenario.scoreArray[i].label + ": " + rootIcon.scenario.scoreArray[i].score + "<br>";    if (i < 2){      scoreString = scoreString + "<br>";    }  }}  // help the page author by reminding themif (pageMode = "development"){  if (scoreString == "" || scoreString == undefined){    scoreString = rootIcon.scenario.lang[0].scoresDebugMessage;  }}]]></SCR>		<SCR isFunc="1" id="fnSetUpscenario" name="fnSetUpscenario"><![CDATA[/** This script is used as a function* it calls the functions * fnPropAction()* fnscenarioAction() * fnUpdateScore()* fnScoreDisplay()* to set up the scenario display* when the page loads and each time the user selects an action*/// fnSetUpscenarioscenarioTitle = pageIcon.templateData.scenario[projPI].title;scenarioTitleText.setText("<b>" + scenarioTitle + "</b>");fnPropAction();  // call function to set up prop based actionsfnscenarioAction();  // call function to set up scenario based actionsscenarioDesc = pageIcon.templateData.scenario[projPI].description;// add any effects and their outcomes to the scenario//effectList = "";if (effectArray.length != undefined){	scenarioDesc = scenarioDesc + "<br><br>";	for (i = 0; i < effectArray.length; i++) {		// go through each effect that has by now been checked for action conditions being met		// we still have to consider outcomeConditions		if (!(effectArray[i].actionText == undefined || effectArray[i] == "")){			scenarioDesc = scenarioDesc + "<br>" + effectArray[i].actionText;		}		if (effectArray[i].length != undefined) {			// there are outcomes			for (j = 0; j < effectArray[i].length; j++) {				allowOutcome = "true";								// need to set up test for outcomeConditions here				if (effectArray[i][j].length != undefined) {					// we have outcome conditions						for (k = 0; k < effectArray[i][j].length; k++) {						// we have outcomeConditions for this outcome						if (effectArray[i][j][k].propName != undefined) {							thisProp = effectArray[i][j][k].propName;							// find array for this prop							thisPropIndex = rootIcon.scenario.propIndexArray.findValue(thisProp);          							if (thisPropIndex != -1){ // prop can be found								switch(effectArray[i][j][k].propState){									case "visible":										if (visibleArray.findValue(thisPropIndex) == -1){											// prop is not present in visibleArray											allowOutcome = "false";										}										break;									case "hidden":										if (hiddenArray.findValue(thisPropIndex) == -1){											// not hiding;											allowOutcome = "false";										}										break;            									default: // undefined								}								// switch case propLoc  								switch(effectArray[i][j][k].propLoc){									case "onStage":										if (onStageArray.findValue(thisPropIndex) == -1) {  // prop is not present in presentArray											allowOutcome = "false";										}										break;									case "carried":										if (carriedArray.findValue(thisPropIndex) == -1){											// carried;											allowOutcome = "false";										}										break;									case "offStage":										if (offStageArray.findValue(thisPropIndex) == -1){											allowOutcome = "false";										}             										break;									case "notOnStage":										if (notOnStageArray.findValue(thisPropIndex) == -1){											// not hiding;											allowOutcome = "false";										}										break;            									case "notCarried":										if (notCarriedArray.findValue(thisPropIndex) == -1){											// not carried;											allowOutcome = "false";										}										break;									case "inScene":										if (inSceneArray.findValue(thisPropIndex) == -1){											// not accessible;											allowOutcome = "false";										}										break;                                    									default: // undefined										// no action required if no propState value specified								} //  end switch case propState 							} else {								// this prop does not exist in propIndexArray								allowOutcome = "false";							} // end if propIndex test						} // if propName undefined - end of prop condition tests						// now test the scenario related options						if (effectArray[i][j][k].scenarioID != undefined){ // name of scenario in condition							// need to test values for scenarioState							switch(effectArray[i][j][k].scenarioState){								// prop that is the subject of the condition may not be the same as the prop that has the action								case "current":									if (effectArray[i][j][k].scenarioID != currentscenario){										// test is current but condition scenario value is not current scenario										allowOutcome = "false";									}									break;								case "notCurrent":									if (effectArray[i][j][k].scenarioID == currentscenario){										// test is notCurrent but condition scenario value is the current scenario										allowOutcome = "false";									}              									break;								default: // undefined									// reject action as improperly formed condition									allowOutcome = "false";              							} // switch 						} // if scenarioID specified																	// now test for score value						if (effectArray[i][j][k].scoreNumber != undefined){ // name of scenario in condition      							// need to test values for specified score							switch(effectArray[i][j][k].scoreNumber){								case "1":									testScore = rootIcon.scenario.scoreArray[0].score;									break;								case "2":									testScore = rootIcon.scenario.scoreArray[1].score;                									break;								case "3":									testScore = rootIcon.scenario.scoreArray[2].score;                									break;								case "4":									// inventory									testScore = inventoryArray.length;                									break;									default: // undefined									// reject action as improperly formed condition									allowOutcome = "false"; 							}	 							switch(effectArray[i][j][k].scoreComp){								// prop that is the subject of the condition may not be the same as the prop that has the action								case "LT":									if (testScore >= effectArray[i][j][k].scoreVal){										// test is current but condition scenario value is not current scenario										allowOutcome = "false";									}									break;								case "GT":									if (testScore <= effectArray[i][j][k].scoreVal){										// test is notCurrent but condition scenario value is the current scenario										allowOutcome = "false";									}              									break;								case "EQ":									if (effectArray[i][j][k].scoreVal){										// test is notCurrent but condition scenario value is the current scenario										allowOutcome = "false";									}              									break;            								default: // undefined									// reject action as improperly formed condition									allowOutcome = "false"; 							} // switch 						} // if scoreNumber specified    						// now test the chanceAct option against a random number						if (effectArray[i][j][k].chanceAct != undefined){ // name of scenario in condition							// need to test values for scenarioState							myRand = Math.floor(Math.random() * 10); // returns 0 through 9							myChanceAct = parseInt(effectArray[i][j][k].chanceAct);							if (myRand >= myChanceAct){								allowOutcome = "false";							}						}					} // end of outcomeCondition tests loop										// process outcomes of effect only if allowOutcome == "true"					if (allowOutcome == "true") {						if (!(effectArray[i][j].outcomeText == undefined !! effectArray[i][j].outcomeText == "")){							scenarioDesc = scenarioDesc + "<br>" + effectArray[i][j].outcomeText;							// add processing of other outcomes here							// handle any score increments							if (effectArray[i][j].score1Inc != undefined){								scoreIndex = 0;								scoreInc = parseInt(effectArray[i][j].score1Inc);								fnUpdateScore();							}							if (effectArray[i][j].score2Inc != undefined){								scoreIndex = 1;								scoreInc = parseInt(effectArray[i][j].score2Inc);								fnUpdateScore();                							}							if (effectArray[i][j].score3Inc != undefined){								scoreIndex = 2;								scoreInc = parseInt(effectArray[i][j].score3Inc);								fnUpdateScore();                 							}							// handle changes to a prop							if (effectArray[i][j].propName != undefined){								// identify the prop								outcomeProp = effectArray[i][j].propName;								outcomePropIndex = rootIcon.scenario.propIndexArray.findValue(outcomeProp);								if (outcomePropIndex != -1){ // the prop has been found									switch(effectArray[i][j].propState){										case "show":											rootIcon.scenario.propArray[outcomePropIndex].state = "visible";											break;             										case "hide":											rootIcon.scenario.propArray[outcomePropIndex].state = "hidden";            											break;										case "carry":											rootIcon.scenario.propArray[outcomePropIndex].scenario = "Inventory";											break;										case "drop":											rootIcon.scenario.propArray[outcomePropIndex].scenario = currentscenario;            											break;										case "offStage":											rootIcon.scenario.propArray[outcomePropIndex].scenario = "Off Stage";											break;                										default									}  // switch								} // if outcomePropIndex							}  // if actionArray.Propname              							// play soundEffect if one has been provided							if (effectArray[i][j].soundEffect != undefined){								// play sound								narration = effectArray[i][j].soundEffect;								// do not broadcast showAudio event from inside the function as this will								// stop the hot text working							}    							// destination change not implemented for effects as this could be confusing							// and is inconsistent with the concept of an effect						}					}				}			}		}	}}// add list of props present at the scenario//if (presentArray.length > 0){if (propsInscenarioArray.length > 0){	//  scenarioDesc = scenarioDesc + "<br><br>" + rootIcon.scenario.lang[0].scenarioPropsTitle + " " + presentArray.length + " " + rootIcon.scenario.lang[0].scenarioPropsName + "<br><br>";	//  for (i=0; i < presentArray.length; i++){	scenarioDesc = scenarioDesc + "<br><br>" + rootIcon.scenario.lang[0].scenarioPropsTitle + " " + propsInscenarioArray.length + " " + rootIcon.scenario.lang[0].scenarioPropsName + "<br><br>";	for (i=0; i < propsInscenarioArray.length; i++){		// list each item in present array to be displayed under the scenario description as hot text items		scenarioDesc = scenarioDesc + '<li><a href="asfunction:_level0.engine.hotText,S' + i + '">' + propsInscenarioArray[i].title+ '</a></li>';	} }  scenarioDescText.setText(scenarioDesc);// set up actionsactionList = "";if (actionArray.length != undefined){	for (i=0; i < actionArray.length; i++){		actionList = actionList + '<a href="asfunction:_level0.engine.hotText,A' + i + '">' + actionArray[i].title + '</a><br><br>';	}}actionListText.setText(actionList);// inventory listinvList = "";if (inventoryArray.length > 0){	inventoryDesc = rootIcon.scenario.lang[0].inventoryTitle + " " + inventoryArray.length + " " + rootIcon.scenario.lang[0].inventoryItemName;	for (i=0; i < inventoryArray.length; i++){		invList = invList + '<li><a href="asfunction:_level0.engine.hotText,I' + i + '">' + inventoryArray[i].title + '</a></li>';	}} else {	invList =   rootIcon.scenario.lang[0].inventoryEmpty;	inventoryDesc = rootIcon.scenario.lang[0].inventoryTitle;}inventoryListText.setText(invList);inventoryTitleText.setText("<b>" + inventoryDesc + "</b>");// scoresfnScoreDisplay();scoreText.setText(scoreString);]]></SCR>		<SCR name="set up layout and page options"><![CDATA[/** This script sets up layout values so that adjustments to the layout of the * panels and text icons can be managed from one central place* * It also sets up the navigation settings for this page and text stri*/// set up panelspageHeight = rootIcon.h - (rootIcon.statusBarHeight + rootIcon.titleBarHeight + rootIcon.titleBannerHeight);colMargin = 10;gutterVal = 10;titleHeight = 30;availableHeight = pageHeight - (3 * colMargin);leftColx = colMargin;colWidth = (rootIcon.w - (3 * colMargin)) /2;leftColw = colWidth;rightColw = colWidth;rightColx = colWidth + (2 * colMargin);// used for scenario text and action listtopPanely = colMargin;topPanelh= (Math.round(availableHeight / 4) * 3);// used for inventory and scoresbottomPanelh = availableHeight - topPanelh;bottomPanely = topPanelh + (colMargin * 2);topMainTexty = topPanely + titleHeight; // ypos for scenario text and action listtopMainTexth = topPanelh - topMainTexty -10;inventoryy = titleHeight + bottomPanely;scorey = bottomPanely + titleHeight;// large panel used for display of action outcome textlargePanelx = Math.round((rootIcon.w - colWidth) / 2);largePanely = Math.round(availableHeight / 4);largePanelh = Math.round(availableHeight / 2);largePanelw = Math.round(rootIcon.w / 2);actionTextx = largePanelx + colMargin;actionTexty = largePanely + colMargin;actionTexth = Math.round(largePanelh - 30 - (colMargin * 2));actionTextw = Math.round(largePanelw - (colMargin * 2));buttonw = rootIcon.scenario.lang[0].continueButtonWidth;buttony = parseInt(largePanely) + parseInt(actionTexth + 10);buttonx = parseInt(actionTextx) + parseInt((actionTextw - buttonw) / 2);if (pageIcon.templateData.scenario[projPI].url != undefined){//  buttonSpace = 50;  // position and display button to display graphic  btnShowGraphicw  = 100;  btnShowGraphicx = leftColx + gutterVal;//  btnShowGraphicy = topPanely + topPanelh + 20 - buttonSpace;  btnShowGraphicy = topPanely + topPanelh -30;  // adjust size of Scenario text display  scenarioTexth = topMainTexth -20;  }  else {//  buttonSpace = 0;  // adjust size of Scenario text display  scenarioTexth = topMainTexth;  }txtPageNotFoundh = 200;txtPageNotFoundw = 250;txtPageNotFoundy = (availableHeight - txtPageNotFoundh) / 2;txtPageNotFoundx = (rootIcon.w - txtPageNotFoundw) / 2;maxImageWidth = colWidth * 2;maxImageHeight = availableHeight;// string settings for development modepageLabel = rootIcon.scenario.lang[0].pageLabel;titleLabel =   rootIcon.scenario.lang[0].titleLabel;idLabel =   rootIcon.scenario.lang[0].idLabel;notFoundMessage =   rootIcon.scenario.lang[0].notFoundMessage;notSetMessage =   rootIcon.scenario.lang[0].notSetMessage;]]></SCR>		<SCR name="processscenarioData"><![CDATA[/** This script sets the current scenario to this page and then checks if this is the first time this page* has been run. If it is the first time this page's name is added to rootIcon.scenario.scenarioIndexArray* and any score changes for visiting this page are acted on. This ensures that scores awarded* for accessing a new scenario page are only earned on the first visit to the page.*/ // send page titles and page ids to clipboard if requestedif ((pageMode == "development") && (pageIcon.templateData.scenario[projPI].listToClip != undefined)){  reportStyle = pageIcon.templateData.scenario[projPI].listToClip;  fnListToClipboard();}// currentscenario value now set in getPageID as its value is dependent on Xerte / XOTgameOver = 0;currentscenarioIndex = rootIcon.scenario.scenarioIndexArray.findValue(currentscenario);if (currentscenarioIndex == -1){  firstTime = "true"; // first time for all items in this page  // add locationID to array  rootIcon.scenario.scenarioIndexArray.push(currentscenario);  currentscenarioIndex = rootIcon.scenario.scenarioIndexArray.length -1;  // add score for getting to this location for the first time.  if (!isNaN(parseInt(pageIcon.templateData.scenario[projPI].score1Inc))){    scoreIndex = 0;    scoreInc = parseInt(pageIcon.templateData.scenario[projPI].score1Inc);    fnUpdateScore();  }  if (!isNaN(parseInt(pageIcon.templateData.scenario[projPI].score2Inc))){    scoreIndex = 1;    scoreInc = parseInt(pageIcon.templateData.scenario[projPI].score2Inc);    fnUpdateScore();  }    if (!isNaN(parseInt(pageIcon.templateData.scenario[projPI].score3Inc))){    scoreIndex = 2;    scoreInc = parseInt(pageIcon.templateData.scenario[projPI].score3Inc);    fnUpdateScore();  }    } else {  firstTime = "false";} ]]></SCR>		<SCR name="processPropData"><![CDATA[/** The first time a page is accessed the details of the props referenced in this page* are stored in the following persistent arrays* prop Name in rootIcon.scenario.propIndexArray* Full details of the prop in rootIcon.scenario.propArray*/ // add items to item array if this is the first time the page has loadedif (firstTime == "true"){  if (pageIcon.templateData.scenario[projPI].propList[0].prop.length != undefined){  // we have props    for (i=0; i < pageIcon.templateData.scenario[projPI].propList[0].prop.length; i++){      currentProp =  pageIcon.templateData.scenario[projPI].propList[0].prop[i].name;      currentPropTitle = pageIcon.templateData.scenario[projPI].propList[0].prop[i].title;      currentPropDesc = pageIcon.templateData.scenario[projPI].propList[0].prop[i].description;      currentPropState = pageIcon.templateData.scenario[projPI].propList[0].prop[i].state;      if (rootIcon.scenario.propIndexArray.findValue(currentProp) == -1){        // first time for this prop add its name to the index array        rootIcon.scenario.propIndexArray.push(currentProp);        rootIcon.scenario.propscenarioArray.push(currentscenario);      }      // add current prop details to propArray      propIndex = rootIcon.scenario.propIndexArray.findValue(currentProp);      rootIcon.scenario.propArray[propIndex] = new Array();      rootIcon.scenario.propArray[propIndex].elementType = "prop";      rootIcon.scenario.propArray[propIndex].name = currentProp;      rootIcon.scenario.propArray[propIndex].title = currentPropTitle;      rootIcon.scenario.propArray[propIndex].description = currentPropDesc;      rootIcon.scenario.propArray[propIndex].state = currentPropState;      rootIcon.scenario.propArray[propIndex].scenario = currentscenario;           // add actions to current prop      if (pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction.length != undefined){        for (k=0; k < pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction.length; k++){           rootIcon.scenario.propArray[propIndex][k] = new Array(); // first add actions          rootIcon.scenario.propArray[propIndex][k].elementType = "action";		            rootIcon.scenario.propArray[propIndex][k].name = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].name;                    rootIcon.scenario.propArray[propIndex][k].title = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].title;                    rootIcon.scenario.propArray[propIndex][k].actionText = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionText;          rootIcon.scenario.propArray[propIndex][k].actionType = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionType;               // add action conditions to propArray[propIndex][0][0]          if (pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition.length != undefined){            rootIcon.scenario.propArray[propIndex][k][0] = new Array(); // for conditions            for (j=0; j < pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition.length; j++){              rootIcon.scenario.propArray[propIndex][k][0][j] = new Array();              rootIcon.scenario.propArray[propIndex][k][0][j].elementType = "condition";              rootIcon.scenario.propArray[propIndex][k][0][j].name = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].name;                             rootIcon.scenario.propArray[propIndex][k][0][j].propName = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].propName;               rootIcon.scenario.propArray[propIndex][k][0][j].propState = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].propState;               rootIcon.scenario.propArray[propIndex][k][0][j].propLoc = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].propLoc;               rootIcon.scenario.propArray[propIndex][k][0][j].scenarioID = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].scenarioID;               rootIcon.scenario.propArray[propIndex][k][0][j].scenarioState = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].scenarioState;               rootIcon.scenario.propArray[propIndex][k][0][j].scoreNumber = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].scoreNumber;               rootIcon.scenario.propArray[propIndex][k][0][j].scoreVal = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].scoreVal;               rootIcon.scenario.propArray[propIndex][k][0][j].scoreComp = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].scoreComp;                 rootIcon.scenario.propArray[propIndex][k][0][j].chanceAct = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionCondition[j].chanceAct;                                   }          }          // add action outcomes to propArray[propIndex][0][0]          if (pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome.length != undefined){            rootIcon.scenario.propArray[propIndex][k][1] = new Array(); // for outcomes            for (j=0; j < pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome.length; j++){              rootIcon.scenario.propArray[propIndex][k][1][j] = new Array();              rootIcon.scenario.propArray[propIndex][k][1][j].elementType = "outcome";              rootIcon.scenario.propArray[propIndex][k][1][j].name = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].name;               rootIcon.scenario.propArray[propIndex][k][1][j].outcomeText = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeText;               rootIcon.scenario.propArray[propIndex][k][1][j].score1Inc = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].score1Inc;               rootIcon.scenario.propArray[propIndex][k][1][j].score2Inc = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].score2Inc;               rootIcon.scenario.propArray[propIndex][k][1][j].score3Inc = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].score3Inc;               rootIcon.scenario.propArray[propIndex][k][1][j].propName = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].propName;               rootIcon.scenario.propArray[propIndex][k][1][j].propState = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].propState;              rootIcon.scenario.propArray[propIndex][k][1][j].propAction = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].propAction;              rootIcon.scenario.propArray[propIndex][k][1][j].specifiedLoc = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].specifiedLoc;              rootIcon.scenario.propArray[propIndex][k][1][j].destination = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].destination;               rootIcon.scenario.propArray[propIndex][k][1][j].soundEffect = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].soundEffect;              // add outcome conditions to this outcome              if (pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition.length != undefined){                for (m=0; m < pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition.length; m++){                  rootIcon.scenario.propArray[propIndex][k][1][j][m] = new Array(); // for outcomeConditions                  rootIcon.scenario.propArray[propIndex][k][1][j][m].elementType = "outcomeCondition";                  rootIcon.scenario.propArray[propIndex][k][1][j][m].name = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].name;                                    rootIcon.scenario.propArray[propIndex][k][1][j][m].propName = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].propName;                  rootIcon.scenario.propArray[propIndex][k][1][j][m].propState = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].propState;                  rootIcon.scenario.propArray[propIndex][k][1][j][m].propLoc = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].propLoc;                  rootIcon.scenario.propArray[propIndex][k][1][j][m].scenarioID = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].scenarioID;                  rootIcon.scenario.propArray[propIndex][k][1][j][m].scenarioState = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].scenarioState;                  rootIcon.scenario.propArray[propIndex][k][1][j][m].scoreNumber = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].scoreNumber;                  rootIcon.scenario.propArray[propIndex][k][1][j][m].scoreVal = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].scoreVal;                  rootIcon.scenario.propArray[propIndex][k][1][j][m].scoreComp = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].scoreComp;                  rootIcon.scenario.propArray[propIndex][k][1][j][m].chanceAct = pageIcon.templateData.scenario[projPI].propList[0].prop[i].userAction[k].actionOutcome[j].outcomeCondition[m].chanceAct;                 }              }            }           }        }      }    }  }}]]></SCR>		<DIS h="topPanelh" w="leftColw" tabIndex="-1" id="scenarioPanel" name="scenarioPanel" x="leftColx" y="topPanely" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<INT name="loadscenarioPanel" perpetual="0">			<RES name="onLoad" type="event" eventName="onLoad" icon="scenarioPanel" erase="1" exit="1">				<SCR name="exit"><![CDATA[//ok to move on]]></SCR>			</RES>		</INT>		<DIS h="topPanelh" w="rightColw" tabIndex="-1" id="actionPanel" name="actionPanel" x="rightColx" y="topPanely" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<INT name="loadactionPanel" perpetual="0">			<RES name="onLoad" type="event" eventName="onLoad" icon="actionPanel" erase="1" exit="1">				<SCR name="exit"><![CDATA[//ok to move on]]></SCR>			</RES>		</INT>		<DIS h="bottomPanelh" w="rightColw" tabIndex="-1" id="scorePanel" name="scorePanel" x="rightColx" y="bottomPanely" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<INT name="loadscorePanel" perpetual="0">			<RES name="onLoad" type="event" eventName="onLoad" icon="scorePanel" erase="1" exit="1">				<SCR name="exit"><![CDATA[//ok to move on]]></SCR>			</RES>		</INT>		<DIS h="bottomPanelh" w="leftColw" tabIndex="-1" id="invPanel" name="invPanel" x="leftColx" y="bottomPanely" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<INT name="loadinvPanel" perpetual="0">			<RES name="onLoad" type="event" eventName="onLoad" icon="invPanel" erase="1" exit="1">				<SCR name="exit"><![CDATA[//ok to move on]]></SCR>			</RES>		</INT>		<DIS textSize="16" id="scenarioTitleText" name="scenarioTitleText" x="leftColx" y="topPanely" w="leftColw" h="titleHeight" type="text"><![CDATA[]]></DIS>		<DIS scrolling="auto" id="scenarioDescText" name="scenarioDescText" x="leftColx" y="topMainTexty" w="leftColw" h="scenarioTexth" type="text"><![CDATA[]]></DIS>		<DIS textSize="16" id="inventoryTitleText" name="inventoryTitleText" x="leftColx " y="bottomPanely" w="leftColw" h="titleHeight" type="text"><![CDATA[{rootIcon.scenario.lang[0].inventoryTitle}]]></DIS>		<DIS id="inventoryListText" name="inventoryListText" x="leftColx " y="bottomPanely + titleHeight" w="leftColw" h="bottomPanelh - titleHeight" type="text"><![CDATA[]]></DIS>		<DIS textSize="16" id="actionsTitleText" name="actionsTitleText" x="rightColx" y="topPanely" w="rightColw " h="titleHeight" type="text"><![CDATA[{"<b>" + rootIcon.scenario.lang[0].actionTitle + "</b>"}]]></DIS>		<DIS scrolling="auto" id="actionListText" name="actionListText" x="rightColx" y="topMainTexty" w="rightColw " h="topMainTexth" type="text"><![CDATA[]]></DIS>		<DIS textSize="16" id="scoreTitle" name="scoreTitle" x="rightColx" y="bottomPanely" w="rightColw " h="titleHeight" type="text"><![CDATA[{"<b>" + rootIcon.scenario.lang[0].scoresTitle + "</b>"}]]></DIS>		<DIS textSize="12" id="scoreText" name="scoreText" x="rightColx" y="scorey" w="rightColw" h="20" type="text"><![CDATA[]]></DIS>		<DIS embedVars="1" textColour="#FF0000" textSize="20" id="txtPageNotFound" name="txtPageNotFound" x="txtPageNotFoundx" y="txtPageNotFoundy" w="txtPageNotFoundw" h="txtPageNotFoundh" type="text"><![CDATA[]]></DIS>		<SCR name="playscenario"><![CDATA[/** This script just sets up some values that could not be set until the icons affected have loaded* It also removes icons related to the use of swf, graphic or flv files if * a url optional property has not been assigned by the author.* If narration has been assigned a file then the showAudio event is now broadcast* Note: If a narration file is assigned to the scenario and an effect is also assigned a* sound file then the effect file will play as the scenario data is processed before the * effect data, thus the effect sound file name will replace the scenario narration file name value*/fnSetUpscenario();scenarioTitleText.setGutter(gutterVal);scenarioDescText.setGutter(gutterVal);inventoryTitleText.setGutter(gutterVal);inventoryListText.setGutter(gutterVal);actionsTitleText.setGutter(gutterVal);actionListText.setGutter(gutterVal);scoreTitle.setGutter(gutterVal);scoreText.setGutter(gutterVal);txtPageNotFound.setGutter(gutterVal);if (icon.built != 'true'){  icon.built = 'true';  mediaFileType = "u";      if (pageIcon.templateData.scenario[projPI].url != undefined){    mediaString = pageIcon.templateData.scenario[projPI].url.toLowerCase();    // find out the type of file we have      if (mediaString.lastIndexOf(".flv") != -1){      // flv      mediaFileType = "v";      // size the video display      if (pageIcon.templateData.scenario[projPI].movieSize != undefined){        icon.parentNode.getChildByName('movie').attributes.w = pageIcon.templateData.scenario[projPI].movieSize.split(',')[0];        icon.parentNode.getChildByName('movie').attributes.h = pageIcon.templateData.scenario[projPI].movieSize.split(',')[1];      }      vidURL = pageIcon.templateData.scenario[projPI].url;      //support for links from moletv      if (vidURL.indexOf('moletv.org.uk') != -1){        vid = vidURL.split('=')[1];        vidURL = "'http://www.moletv.org.uk/mod/FileStream.aspx?v=" + vid + "&t=1&z=.flv'"      }    } else if (mediaString.lastIndexOf(".swf") != -1){        // swf      mediaFileType = "s";      //control bar?      if (pageIcon.templateData.scenario[projPI].controls != undefined && pageIcon.templateData.scenario[projPI].controls != 'Control Bar'){        icon.parentNode.getChildByName('graphic').attributes.controls = 0;        vSpace = 0;      } else {        vSpace = 20;      }                } else {      // treat it as a graphic image file      mediaFileType = "i";       icon.parentNode.getChildByName('graphic').attributes.controls = 0;      vSpace = 0;           }  }      // now we know the type of file  if (!(mediaFileType == "i" || mediaFileType == "s")){    // video files don't use the following icons    icon.parentNode.getChildByName("graphic").removeNode();    icon.parentNode.getChildByName("loadGraphic").removeNode();    icon.parentNode.getChildByName("mask").removeNode();  }   // remove all video elements if no video specified  if (mediaFileType != "v"){    icon.parentNode.getChildByName("movie").removeNode();    icon.parentNode.getChildByName("loadVideo").removeNode();  }  // remove all media file related icons as no file specified  if (mediaFileType == "u"){    icon.parentNode.getChildByName("graphicDisplay").removeNode();    icon.parentNode.getChildByName("graphic").removeNode();    icon.parentNode.getChildByName("loadGraphic").removeNode();    icon.parentNode.getChildByName("mask").removeNode();     icon.parentNode.getChildByName("movie").removeNode();    icon.parentNode.getChildByName("loadVideo").removeNode();        }// trigger narration now that any effect actions have loadedif (narration != undefined){  rootIcon.broadcast('showAudio');}]]></SCR>		<DIS tabIndex="-1" id="panel" name="panel" x="-300" y="20" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<INT name="loadPanel" perpetual="0">			<RES name="onLoad" type="event" eventName="onLoad" icon="panel" erase="1" exit="1">				<SCR name="calculate"><![CDATA[//ok to move on]]></SCR>			</RES>		</INT>		<DIS controls="1" toolTip="" id="graphic" name="graphic" x="20" y="50" type="ext" url="{pageIcon.templateData.scenario[projPI].url}"><![CDATA[]]></DIS>		<DIS id="mask" name="mask" x="0" y="0" type="ext" url="FileLocation + "><![CDATA[]]></DIS>		<INT id="intLoadGraphic" name="loadGraphic" perpetual="0">			<RES name="onLoad" type="event" eventName="onLoad" icon="graphic" erase="1" exit="1">				<SCR name="calculate"><![CDATA[// size and position graphic then make it invisiblemaxImageWidth = colWidth * 2;maxImageHeight = availableHeight;if (pageIcon.templateData.scenario[projPI].movieSize != undefined){  graphic._width = pageIcon.templateData.scenario[projPI].movieSize.split(',')[0];  graphic._height = pageIcon.templateData.scenario[projPI].movieSize.split(',')[1];}if (pageIcon.templateData.scenario[projPI].initObject != undefined){  obj = expression(pageIcon.templateData.scenario[projPI].initObject, engine);  graphic.clip.init(obj);}graphic.constrain(maxImageWidth, maxImageHeight);graphic.tooltip = "Click on graphic to hide it";graphic._y = ((availableHeight - graphic._height) /2) + (colMargin * 1.5);graphic._x = (rootIcon.w - graphic._width) /2;//resize the panel to the graphicpanel._width = graphic._width + (2 * colMargin);panel._height = graphic._height + (2 * colMargin) + vSpace;//panel._height = graphic._height + 20;panel._x = graphic._x - colMargin;panel._y = graphic._y - colMargin;mask._x = graphic._x;mask._y = graphic._y;mask.beginFill(0xFF0000,100);mask.drawRect(0,0,graphic._width, graphic._height + 21);graphic.setMask(mask);//kil xerte events?if (pageIcon.templateData.scenario[projPI].controls == 'Native SWF'){  graphic.onRollOver = null;  delete graphic.onRollOver;  graphic.onRollOut = null;  delete graphic.onRollOut;  graphic.onSetFocus = null;  delete graphic.onSetFocus;}graphic._visible = 0;panel._visible = 0;// position hide button to make graphic invisible againif (pageIcon.templateData.scenario[projPI].hideButtonPos == "0"){  btnHideGraphicx = btnShowGraphicx;  btnHideGraphicy = btnShowGraphicy;  } else {  btnHideGraphicx = graphic._x + 10;  btnHideGraphicy = graphic._y + graphic._height - 40;}]]></SCR>			</RES>		</INT>		<MOV id="movie" name="movie" x="0" y="30" url="{vidURL}" controls="1" play="0"><![CDATA[{pageIcon.templateData.scenario[projPI].tip}]]></MOV>		<INT name="loadVideo" perpetual="0">			<RES name="onMovieReady" type="event" eventName="onMovieReady" icon="movie" erase="1" exit="1">				<SCR name="calculate"><![CDATA[//resize the panel to the graphic//graphic._y = (availableHeight - graphic._height) /2;//graphic._x = (rootIcon.w - graphic._width) /2;//graphic.glow(ox00FFCC,50,20,20);//graphic._visible = 0;maxImageWidth = colWidth * 2;maxImageHeight = availableHeight;movie.constrain(maxImageWidth, maxImageHeight);panel._width = movie._width + 20;panel._height = movie._height + 20;movie._x = (rootIcon.w - movie._width) /2;movie._y = (availableHeight - movie._height) /2;panel._x = movie._x - 10;panel._y = movie._y -10;if (pageIcon.templateData.scenario[projPI].reset == 'false'){  movie.flvPlayer.autoRewind = false;}initW = movie._width;initH = movie._height;initX = movie._x;initY = movie._y;doOnResize = "true";movie._visible = 0;panel._visible = 0;// position hide button to make movie invisible againif (pageIcon.templateData.scenario[projPI].hideButtonPos == "0"){  btnHideGraphicx = btnShowGraphicx;  btnHideGraphicy = btnShowGraphicy;} else {  btnHideGraphicx = movie._x + 10;  btnHideGraphicy = (movie._y + movie._height) - 50;}]]></SCR>			</RES>		</INT>		<INT id="graphicDisplay" name="graphicDisplay" perpetual="1">			<RES w="rootIcon.scenario.lang[0].imageButtonWidth" visible="1" swf="templatePath + 'common/button.swf'" rs="btnShowGraphic" name="btnShowGraphic" type="button" x="btnShowGraphicx" y="btnShowGraphicy" label="{rootIcon.scenario.lang[0].imageButtonShow}" erase="1" exit="0">				<SCR name="[Untitled]"><![CDATA[  btnShowGraphic._visible = 0;  if (mediaFileType == "i" || mediaFileType == "s"){    graphic.fade('in', 1, 'None', 'easeNone');    panel.fade('in', 1, 'None', 'easeNone');    /*  } else if (mediaFileType == "s") {    graphic.fade('in', 1, 'None', 'easeNone');     panel.fade('in', 1, 'None', 'easeNone');           */  } else if (mediaFileType == "v") {    movie.fade('in', 1, 'None', 'easeNone');    panel.fade('in', 1, 'None', 'easeNone');  }]]></SCR>				<INT name="[Untitled]" perpetual="0">					<RES name="graphicOnMotion" type="event" eventName="onMotionFinished" icon="graphic" erase="1" exit="0">						<SCR name="[Untitled]"><![CDATA[  btnHideGraphic._visible = 1; ]]></SCR>					</RES>					<RES name="movieOnMotion" type="event" eventName="onMotionFinished" icon="movie" erase="1" exit="0">						<SCR name="[Untitled]"><![CDATA[  btnHideGraphic._visible = 1; ]]></SCR>					</RES>				</INT>			</RES>			<RES w="rootIcon.scenario.lang[0].imageButtonWidth" visible="0" swf="templatePath + 'common/button.swf'" rs="btnHideGraphic" name="btnHideGraphic" type="button" x="btnHideGraphicx" y="btnHideGraphicy" label="{rootIcon.scenario.lang[0].imageButtonHide}" erase="1" exit="0">				<SCR name="[Untitled]"><![CDATA[btnHideGraphic._visible = 0;  if (mediaFileType == "i" || mediaFileType == "s"){ // graphic.hidTip();  graphic.fade('out', 1, 'None', 'easeNone');  panel.fade('out', 1, 'None', 'easeNone');/*  } else if (mediaFileType == "s") {  graphic.fade('out', 1, 'None', 'easeNone');  panel.fade('out', 1, 'None', 'easeNone');   */} else if (mediaFileType == "v") {  movie.stop();  movie.fade('out', 1, 'None', 'easeNone');  panel.fade('out', 1, 'None', 'easeNone');}]]></SCR>				<INT name="[Untitled]" perpetual="0">					<RES name="graphicOnMotion" type="event" eventName="onMotionFinished" icon="graphic" erase="1" exit="0">						<SCR name="[Untitled]"><![CDATA[  btnShowGraphic._visible = 1;]]></SCR>					</RES>					<RES name="movieOnMotion" type="event" eventName="onMotionFinished" icon="movie" erase="1" exit="0">						<SCR name="[Untitled]"><![CDATA[  btnShowGraphic._visible = 1;]]></SCR>					</RES>				</INT>			</RES>		</INT>		<INT name="interactions" perpetual="0">			<RES name="hotText capture" type="event" eventName="onHotText" icon="rootIcon" erase="1" exit="0">				<DIS h="largePanelh" w="largePanelw" tabIndex="-1" id="largePanel" name="largePanel" x="largePanelx" y="largePanely" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>				<INT name="loadlargePanel" perpetual="0">					<RES name="onLoad" type="event" eventName="onLoad" icon="largePanel" erase="1" exit="1">						<SCR name="exit"><![CDATA[//ok to move on]]></SCR>					</RES>				</INT>				<DIS scrolling="auto" id="actionText" name="actionText" x="actionTextx" y="actionTexty" w="actionTextw" h="actionTexth" type="text"><![CDATA[]]></DIS>				<SCR name="process action or inventory"><![CDATA[// process action or inventorychangeScore1 = 0;changeScore2 = 0;changeScore3 = 0;actionSource = rootIcon.hotTextClicked.charAt(0);actionOutcomeText = "";destPageName = undefined;outcomeIndex = parseInt(rootIcon.hotTextClicked.substr(1, rootIcon.hotTextClicked.length - 1));if (actionSource == "A"){ // action list item	if (actionArray[outcomeIndex].length != undefined){		actionOutcomeText = actionOutcomeText + actionArray[outcomeIndex].actionText + "...<br><br>";		// loop through actionArray outcomes for this action (there is only one action here selected by the user!)		for (i = 0; i < actionArray[outcomeIndex].length; i++) {			// loop through the outcomes			actionOutcomeText = actionOutcomeText + actionArray[outcomeIndex][i].outcomeText + "<br>";			// handle any score increments			if (actionArray[outcomeIndex][i].score1Inc != undefined){            changeScore1 = changeScore1 + parseInt(actionArray[outcomeIndex][i].score1Inc);		}			if (actionArray[outcomeIndex][i].score2Inc != undefined){            changeScore2 = changeScore2 + parseInt(actionArray[outcomeIndex][i].score2Inc);		}			if (actionArray[outcomeIndex][i].score3Inc != undefined){            changeScore3 = changeScore3 + parseInt(actionArray[outcomeIndex][i].score3Inc);			}			// handle changes to a prop			if (actionArray[outcomeIndex][i].propName != undefined){				// identify the prop				outcomeProp = actionArray[outcomeIndex][i].propName;				outcomePropIndex = rootIcon.scenario.propIndexArray.findValue(outcomeProp);				if (outcomePropIndex != -1){ // the prop has been found					// do state					switch(actionArray[outcomeIndex][i].propState){						case "visible":							rootIcon.scenario.propArray[outcomePropIndex].state = "visible";							break;             						case "hidden":							rootIcon.scenario.propArray[outcomePropIndex].state = "hidden";            							break;						default:							// do nothing					}  // switch					// do propAction					switch(actionArray[outcomeIndex][i].propAction){						case "carry":							rootIcon.scenario.propArray[outcomePropIndex].scenario = "Inventory";							break;						case "drop":							rootIcon.scenario.propArray[outcomePropIndex].scenario = currentscenario;            							break;						case "specified":							// check if specified location exists							propScenarioIndex = rootIcon.scenario.scenarioIndexArray.findValue(actionArray[outcomeIndex][i].specifiedLoc);          							if (propScenarioIndex != -1){              								rootIcon.scenario.propArray[outcomePropIndex].scenario = specifiedLoc;							}							break;                						case "destroy":							rootIcon.scenario.propArray[outcomePropIndex].scenario = "Off Stage";							break;              						default:							// do nothing					}  // switch				} // if outcomePropIndex			}  // if actionArray.Propname              			// play soundEffect if one has been provided			if (actionArray[outcomeIndex][i].soundEffect != undefined){				// play sound				narration = actionArray[outcomeIndex][i].soundEffect;				rootIcon.broadcast('showAudio');			}  			// now need to set up the destination			if (actionArray[outcomeIndex][i].destination != undefined){    				destPageName = actionArray[outcomeIndex][i].destination;			}		} // outcome index loop	} //outcomeIndex undefined		} else if (actionSource == "I"){  // inventory list item selected	actionOutcomeText = inventoryArray[outcomeIndex].description;} else {	// you can see list	actionOutcomeText = propsInscenarioArray[outcomeIndex].description}  actionText.setText(actionOutcomeText);actionText._visible = true;largePanel._visible = true;]]></SCR>				<INT name="Continue interaction" perpetual="0">					<RES w="rootIcon.scenario.lang[0].continueButtonWidth" swf="templatePath + 'common/button.swf'" name="Continue" type="button" x="buttonx" y="buttony" label="{rootIcon.scenario.lang[0].btnContinueLabel}" erase="1" exit="1">						<SCR name="go to page"><![CDATA[actionText._visible = false;largePanel._visible = false;txtPageNotFound._visible = 0;// update scores - which may trigger a game endif (changeScore1 != 0){  scoreIndex = 0;  scoreInc = parseInt(changeScore1);  fnUpdateScore();}if (changeScore2 != 0){  scoreIndex = 1;  scoreInc = parseInt(changeScore2);  fnUpdateScore();}if (changeScore3 != 0){  scoreIndex = 2;  scoreInc = parseInt(changeScore3);  fnUpdateScore();}if (rootIcon.scenario.scoreArray.gameOver != "true";){  	pageFound = "true";	if (destPageName == undefined){		// re-run scenario set up to display changes of score, property location etc.		fnSetUpscenario();	} else if (destPageName == "") {		// error in setup as a destination has been added to the outcome but no value specified		txtPageNotFound.setText(notSetMessage);		pageFound = "false";		//  fnSetUpscenario();	} else {  // a destination has been specified 		// only go to new page if game is not over		// navigate to destination page		for (i = 0; i < pageID_array.length; i++){			if (pageID_array[i] == destPageName){				pageFound = "true";				destinationIndex = i;				rootIcon.gotoPage(destinationIndex  + navOffset);  				break;			} else {				pageFound = "false";				// pageID was set but not found				txtPageNotFound.setText(idLabel + "<br>" + destPageName + "<br>" + notFoundMessage)			}		}	}} if ((pageFound == "false") && (pageMode == "development")){  txtPageNotFound.clear();// set up page not found text box  txtPageNotFound.beginFill(0xFFFFCC, 100);  txtPageNotFound.lineStyle(1,0x000000,100);  txtPageNotFound.drawRect(0,0,txtPageNotFoundw,txtPageNotFoundh,10);  txtPageNotFound.dropShadow(7,45,0x999999,50);  txtPageNotFound._visible = 1;  txtPageNotFound.wipe('in',0.25,'Strong','easeIn',2)    }]]></SCR>					</RES>				</INT>			</RES>			<RES name="endGamecapture" type="event" eventName="onGameEnd" icon="rootIcon" erase="1" exit="0">				<DIS h="largePanelh" w="largePanelw" tabIndex="-1" id="largePanelGE" name="largePanelGE" x="largePanelx" y="largePanely" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>				<INT name="loadlargePanelGE" perpetual="0">					<RES name="onLoad" type="event" eventName="onLoad" icon="largePanelGE" erase="1" exit="1">						<SCR name="exit"><![CDATA[//ok to move on]]></SCR>					</RES>				</INT>				<DIS scrolling="auto" id="endGameText" name="endGameText" x="actionTextx" y="actionTexty" w="actionTextw" h="actionTexth" type="text"><![CDATA[]]></DIS>				<SCR name="process end game"><![CDATA[//actionSource = rootIcon.hotTextClicked.charAt(0);gameOverText = "";fnScoreDisplay();gameOverText = scoreString;endDestination="";destPageName = rootIcon.scenarioStartPage;// loop through endGameState values to identify messages required.for (i = 0; i < 3; i++){  if(rootIcon.scenario.scoreArray[i].endGameState == "W"){    gameOverText = gameOverText + "<br>" + rootIcon.scenario.scoreArray[i].winMessage;    endDestination = rootIcon.scenario.scoreArray[i].winEndID;  } else if (rootIcon.scenario.scoreArray[i].endGameState == "L") {    gameOverText = gameOverText + "<br>" + rootIcon.scenario.scoreArray[i].loseMessage;    endDestination = rootIcon.scenario.scoreArray[i].loseEndID;    }}endGameText.setText(gameOverText);endGameText._visible = true;largePanelGE._visible = true;// destroy simulation array so that initialisation will be triggeredrootIcon.scenario.splice(0);rootIcon.scenario = null; ]]></SCR>				<INT name="Continue interaction" perpetual="0">					<RES w="rootIcon.scenario.lang[0].continueButtonWidth" swf="templatePath + 'common/button.swf'" name="Continue" type="button" x="buttonx" y="buttony" label="{rootIcon.scenario.lang[0].btnContinueLabel}" erase="1" exit="1">						<SCR name="go to page"><![CDATA[// end of game takes us back to start so we know the destination is OKendGameText._visible = false;largePanelGE._visible = false;if (endDestination != ""){  for (i = 0; i < pageID_array.length; i++){    if (pageID_array[i] == endDestination){	  	  pageFound = "true";		  destinationIndex = i;		  rootIcon.gotoPage(destinationIndex  + navOffset);  		  break;	    } else {		  pageFound = "false";	    }  }} else {  // navigate to destination page  // new code  for (i = 0; i < pageID_array.length; i++){    if (pageID_array[i] == destPageName){		  pageFound = "true";		  destinationIndex = i;		  rootIcon.gotoPage(destinationIndex  + navOffset);  		  break;	    } else {		  pageFound = "false";	    }  }}]]></SCR>					</RES>				</INT>			</RES>		</INT>	</PG>