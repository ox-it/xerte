	<PG name="gapFill">		<SCR name="getPageID"><![CDATA[pageIcon = icon.parentNode.clip();myXML = new XML(extXML.firstChild.childNodes[rootIcon.getPageIndex() - pgOffset]);pageIcon.templateData = myXML.toObject();rootIcon.setTitleText(templateData.learningObject[0].name);ts = STYLES.inputSize;if (pageIcon.templateData.gapFill[0].image != undefined){  fLoadImage(pageIcon.templateData.gapFill[0].image);} else {  fShowMedia(pageIcon.templateData.gapFill[0].showMedia);}//helpif (pageIcon.templateData.gapFill[0].help != undefined){  helpStr = pageIcon.templateData.gapFill[0].help;  helpIcon._visible = true;} else {  helpIcon._visible = false;}]]></SCR>		<DIS id="textBlock" h="10" name="text" x="380" y="20" w="400" type="text"><![CDATA[{pageIcon.templateData.gapFill[0].text}]]></DIS>		<SCR name="preprocess"><![CDATA[//preparse the textstr = pageIcon.templateData.gapFill[0].passage;str = replace(str, '\r', '');str = replace(str, '  ', ' ');lbls = '';arr = str.split(' ');notes = new Array();for (i = 0; i < arr.length; i++){  if (arr[i].indexOf('|') != -1){      note = new Object();        note.index = i;    note.start = arr[i].indexOf('|');    note.end = arr[i].lastIndexOf('|') - 2;    note.string = arr[i].substr(note.start + 1, note.end - note.start + 1);        lbls += note.string + ' ';        notes.push(note);  }}str = replace(str, '|', '');//add any additional distractorsif (pageIcon.templateData.gapFill[0].noise != undefined){  lbls += pageIcon.templateData.gapFill[0].noise;}]]></SCR>		<DIS tabIndex="-1" id="mainText" name="passage" x="380" y="textBlock._y + textBlock._height + 20" w="400" h="10" type="text"><![CDATA[{str}]]></DIS>		<SCR name="setupInteraction"><![CDATA[n = 0;words = mainText.breakApart(3,7,false, false);targets = new Array();for (i = 0; i < notes.length; i++){  word = words[notes[i].index];    word.tabIndex = -1;    o = word.getRangeMetrics(notes[i].start, notes[i].end);   word.createEmptyMovieClip('mask',9);  word.mask.beginFill(0xFFFF99,100);  word.mask.drawRect(o.start + 2, 2, o.end, o.height);    word.string = notes[i].string;  word.xStart = o.start;  word.xWidth = o.end;    targets.push(word);}]]></SCR>		<DIS tabIndex="-1" textColour="#FF0000" id="lbls" name="lbls" x="mainText._x" y="mainText._y + mainText._height + 10" w="300" h="10" type="text"><![CDATA[{lbls}]]></DIS>		<SCR isFunc="1" name="fHideHint"><![CDATA[hint.removeMovieClip();]]></SCR>		<SCR name="makeInteraction"><![CDATA[//what type of interaction is this?if (pageIcon.templateData.gapFill[0].interactivity == 'Drag Drop'){  labels = lbls.breakApart(13,33,true,true);    for (i = 0; i < labels.length; i++){    labels[i].string = labels[i].txt.text;  }    //randomise position  labels.randomize();  initX = 0;  initY = 0;  for (i = 0; i < labels.length; i++){      labels[i]._x = initX;    labels[i]._y = initY;      initX += labels[i]._width + 3;      if (initX > mainText._width - labels[i]._width){      initX = 0;      initY += 20;    }    //store the initX and Y for replacement    labels[i].initX = labels[i]._x;    labels[i].initY = labels[i]._y;  }  if (icon.attributes.built != 'true'){    icon.nextSibling.firstChild.removeNode();    icon.attributes.built = 'true';  }} else { //fill in the blnk  lbls.removeMovieClip();  icon.nextSibling.childNodes[1].removeNode();    if (icon.attributes.built != 'true'){        icon.nextSibling.firstChild.duplicate(targets.length - 1);    icon.attributes.built = 'true';    for ( i = 0; i < targets.length; i++){      icon.nextSibling.childNodes[i].attributes.answer = targets[i].string;    }  }}lbls.tabChildren = false;count = 0;]]></SCR>		<INT id="gapInt" name="mainInteraction" perpetual="1">			<RES name="protoTextEntry" type="textEntry" x="mainText._x +  targets[icon.index()]._x+ targets[icon.index()].xStart" y="mainText._y + targets[icon.index()]._y" w="targets[icon.index()].xWidth + 4" h="100" phrase="" scrolling="0" border="0" erase="1" exit="0">				<SCR name="onMatch"><![CDATA[tf = icon.parentNode.clip();ans = tf.XMLElement.attributes.answer;//correct...if (ans == tf.text){    tf.border = false;  tf.type = "dynamic";  tf.htmlText = '<font color="#006600">' + tf.text + '</font>';    count++;    targets[icon.parentNode.index()].mask.clear();    Selection.setFocus(icon.parentNode.nextSibling.clip());    if (count == targets.length){    gapInt.broadcast("showFeedback");  }  } else { //not correct yethint.removeMovieClip();  if (tf.text != ans.substr(0, tf.text.length)){    tf.attempts++;  }             if (tf.attempts >= Math.floor(ans.length / 3)){     gapInt.broadcast('showHint');  }}]]></SCR>			</RES>			<RES name="onWordDropped" type="event" eventName="onWordDropped" icon="lbls" erase="1" exit="0">				<SCR name="test"><![CDATA[//check all targetssuccess = false;for (i = 0; i < targets.length; i++){  if (lbls.wordDropped.hitTest(targets[i]) && lbls.wordDropped.string == targets[i].string){    matchedTarget = targets[i];    success = true;    count++;  }}if (success == true){  lbls.wordDropped._x = matchedTarget.xStart + matchedTarget._x - (lbls._x - mainText._x);  lbls.wordDropped._y = matchedTarget._y - (lbls._y - mainText._y);  lbls.wordDropped.onPress = fnull;  lbls.wordDropped.useHandCursor = false;  lbls.wordDropped.colourText('#006600');  } else {  lbls.wordDropped.animate(lbls.wordDropped.initX,lbls.wordDropped.initY,10,'quadBez',1);}if (count == targets.length){  gapInt.broadcast("showFeedback");  }]]></SCR>			</RES>			<RES name="showFeedback" type="event" eventName="showFeedback" icon="gapInt" erase="1" exit="0">				<DIS transition="wipe('in', 0.5, 'None', 'easeNone')" name="feedback" x="380" y="mainText._y + mainText._height + 20" w="400" h="10" type="text"><![CDATA[{pageIcon.templateData.gapFill[0].feedback}]]></DIS>			</RES>			<RES name="showHint" type="event" eventName="showHint" icon="gapInt" erase="1" exit="0">				<SCR name="showHint"><![CDATA[hintStr = '';if (tf.hinted != true){    if (tf.attempts > Math.floor(ans.length / 3)){     hintStr = ans.substr(0,1);    for (i = 1; i < ans.length; i++){      hintStr += '_';    }  }    //last letter  if (tf.attempts > Math.floor(ans.length / 1.5)){     hintStr = ans.substr(0,1);    for (i = 1; i < ans.length - 1; i++){      hintStr += '_';    }    hintStr += ans.substr(ans.length - 1);  }    //random letter  if (tf.attempts > ans.length){     hintStr = ans.substr(0,1);        for (i = 1; i < ans.length - 1; i++){          if (Math.random() < 0.6){        hintStr += '_';      } else {        hintStr += ans.substr(i,1);      }    }    hintStr += ans.substr(ans.length - 1);    tf.hinted = true;  }  tf.hintString = hintStr;}]]></SCR>				<DIS id="hint" name="hint" x="tf._x" y="tf._y - 22" w="400" h="10" type="text"><![CDATA[{tf.hintString}]]></DIS>				<SCR name="draw"><![CDATA[if (tf.hintString != ''){  hint.beginFill(0xFFFFCC,100);  hint.lineStyle(0,0x333333,100);  hint.drawRect(0,2,hint.getTextWidth(),16);}]]></SCR>			</RES>		</INT>		<SCR name="restrictTextFields"><![CDATA[for ( i = 0; i < targets.length; i++){  tA = icon.previousSibling.childNodes[i].clip();  tA.maxChars = targets[i].string.length;  tA.multiline = false;  tA.wordwrap = false;  tA.attempts = 0;  tA.onSetFocus = fHideHint;}]]></SCR>	</PG>